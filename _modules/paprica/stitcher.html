<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>paprica.stitcher &mdash; paprica 0.0.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> paprica
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">How to install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../documentation.html">Generating documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../testing.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API reference:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../paprica.atlaser.html">paprica.atlaser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../paprica.batcher.html">paprica.batcher</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../paprica.converter.html">paprica.converter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../paprica.loader.html">paprica.loader</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../paprica.parser.html">paprica.parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../paprica.segmenter.html">paprica.segmenter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../paprica.stitcher.html">paprica.stitcher</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../paprica.viewer.html">paprica.viewer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../paprica.runner.html">paprica.runner</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">paprica</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">paprica.stitcher</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for paprica.stitcher</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Submodule containing classes and functions relative to **stitching**.</span>

<span class="sd">With this submodule the user can stitch a previously parsed dataset, typically the autofluorescence channel:</span>

<span class="sd">&gt;&gt;&gt; import paprica</span>
<span class="sd">&gt;&gt;&gt; tiles_autofluo = paprica.parser.tileParser(path_to_autofluo, frame_size=1024, overlap=25)</span>
<span class="sd">&gt;&gt;&gt; stitcher = paprica.stitcher.tileStitcher(tiles_autofluo)</span>
<span class="sd">&gt;&gt;&gt; stitcher.compute_registration_fast()</span>

<span class="sd">Others channel can then easily stitched using the previous one as reference:</span>

<span class="sd">&gt;&gt;&gt; tiles_signal = paprica.parser.tileParser(path_to_data, frame_size=1024, overlap=25)</span>
<span class="sd">&gt;&gt;&gt; stitcher_channel = paprica.stitcher.channelStitcher(stitcher, tiles_autofluo, tiles_signal)</span>
<span class="sd">&gt;&gt;&gt; stitcher_channel.compute_rigid_registration()</span>

<span class="sd">Doing that each tile in the second data set will be registered to the corresponding autofluorescence tile and</span>
<span class="sd">then their spatial position will be adjusted.</span>

<span class="sd">WARNING: when stitching, the expected overlap must be HIGHER than the real one. To enforce this, a margin of 20% is</span>
<span class="sd">automatically taken (this margin can be set lower by the user for speed improvement). In order to get the best stitching</span>
<span class="sd">quality it requires to have a good estimate of the overlap, hence why the full volume is not considered.</span>

<span class="sd">This submodule also contains a class for merging and reconstructing the data. It was intended to be used at lower</span>
<span class="sd">resolution for atlasing. The generated data can quickly become out of hands, use with caution!</span>

<span class="sd">By using this code you agree to the terms of the software license agreement.</span>

<span class="sd">© Copyright 2020 Wyss Center for Bio and Neuro Engineering – All rights reserved</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="kn">import</span> <span class="nn">cv2</span> <span class="k">as</span> <span class="nn">cv</span>
<span class="kn">import</span> <span class="nn">dill</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">pyapr</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>
<span class="c1"># from skimage.registration import phase_cross_correlation</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">correlate</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.csgraph</span> <span class="kn">import</span> <span class="n">minimum_spanning_tree</span><span class="p">,</span> <span class="n">depth_first_order</span>
<span class="kn">from</span> <span class="nn">skimage.color</span> <span class="kn">import</span> <span class="n">label2rgb</span><span class="p">,</span> <span class="n">hsv2rgb</span>
<span class="kn">from</span> <span class="nn">skimage.exposure</span> <span class="kn">import</span> <span class="n">equalize_adapthist</span><span class="p">,</span> <span class="n">rescale_intensity</span>
<span class="kn">from</span> <span class="nn">skimage.filters</span> <span class="kn">import</span> <span class="n">gaussian</span>
<span class="kn">from</span> <span class="nn">skimage.metrics</span> <span class="kn">import</span> <span class="n">normalized_root_mse</span>
<span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">warp</span><span class="p">,</span> <span class="n">AffineTransform</span><span class="p">,</span> <span class="n">downscale_local_mean</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">import</span> <span class="nn">napari</span>


<div class="viewcode-block" id="max_sum_over_single_max"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.max_sum_over_single_max">[docs]</a><span class="k">def</span> <span class="nf">max_sum_over_single_max</span><span class="p">(</span><span class="n">reference_image</span><span class="p">,</span> <span class="n">moving_image</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is a reliability metric which works well for sparse data. It computes the 99 percentile of the sum</span>
<span class="sd">    of reference and shifted image divided by twice the 99 percentile of the reference image.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    reference_image: ndarray</span>
<span class="sd">        2D array of the reference image</span>
<span class="sd">    moving_image: ndarray</span>
<span class="sd">        2D array of the moving image image</span>
<span class="sd">    d: array_like</span>
<span class="sd">        registration parameters</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    e: float</span>
<span class="sd">        error estimation of the registration. The lower e, the more reliable the registration.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">shifted_image</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">moving_image</span><span class="p">,</span> <span class="n">AffineTransform</span><span class="p">(</span><span class="n">translation</span><span class="o">=</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span><span class="p">,</span> <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">reference_image</span><span class="p">,</span> <span class="mi">99</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">reference_image</span><span class="o">+</span><span class="n">shifted_image</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">e</span></div>


<div class="viewcode-block" id="mse"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.mse">[docs]</a><span class="k">def</span> <span class="nf">mse</span><span class="p">(</span><span class="n">reference_image</span><span class="p">,</span> <span class="n">moving_image</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalized root mean square error.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    reference_image: ndarray</span>
<span class="sd">        2D array of the reference image</span>
<span class="sd">    moving_image: ndarray</span>
<span class="sd">        2D array of the moving image image</span>
<span class="sd">    d: array_like</span>
<span class="sd">        registration parameters</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    _: float</span>
<span class="sd">        error estimation of the registration. The lower e, the more reliable the registration.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">shifted_image</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">moving_image</span><span class="p">,</span> <span class="n">AffineTransform</span><span class="p">(</span><span class="n">translation</span><span class="o">=</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span><span class="p">,</span>
                         <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">normalized_root_mse</span><span class="p">(</span><span class="n">reference_image</span><span class="p">,</span> <span class="n">shifted_image</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="phase_cross_correlation"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.phase_cross_correlation">[docs]</a><span class="k">def</span> <span class="nf">phase_cross_correlation</span><span class="p">(</span><span class="n">reference_image</span><span class="p">,</span>
                            <span class="n">moving_image</span><span class="p">,</span>
                            <span class="n">upsample_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                            <span class="n">return_error</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Phase cross correlation. Because skimage function compute the NORMAL cross correlation to estimate the shift I</span>
<span class="sd">    modified it to compute the TRUE phase cross correlation, as per the standard definition.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    reference_image : array</span>
<span class="sd">        Reference image.</span>
<span class="sd">    moving_image : array</span>
<span class="sd">        Image to register. Must be same dimensionality as</span>
<span class="sd">        ``reference_image``.</span>
<span class="sd">    upsample_factor : int, optional</span>
<span class="sd">        Upsampling factor. Images will be registered to within</span>
<span class="sd">        ``1 / upsample_factor`` of a pixel. For example</span>
<span class="sd">        ``upsample_factor == 20`` means the images will be registered</span>
<span class="sd">        within 1/20th of a pixel. Default is 1 (no upsampling).</span>
<span class="sd">        Not used if any of ``reference_mask`` or ``moving_mask`` is not None.</span>
<span class="sd">    return_error : bool, optional</span>
<span class="sd">        Returns error and phase difference if on, otherwise only</span>
<span class="sd">        shifts are returned. Has noeffect if any of ``reference_mask`` or</span>
<span class="sd">        ``moving_mask`` is not None. In this case only shifts is returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    shifts : ndarray</span>
<span class="sd">        Shift vector (in pixels) required to register ``moving_image``</span>
<span class="sd">        with ``reference_image``. Axis ordering is consistent with</span>
<span class="sd">        numpy (e.g. Z, Y, X)</span>
<span class="sd">    error : float</span>
<span class="sd">        Translation invariant normalized RMS error between</span>
<span class="sd">        ``reference_image`` and ``moving_image``.</span>
<span class="sd">    phasediff : float</span>
<span class="sd">        Global phase difference between the two images (should be</span>
<span class="sd">        zero if images are non-negative).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># images must be the same shape</span>
    <span class="k">if</span> <span class="n">reference_image</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">moving_image</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;images must be same shape&quot;</span><span class="p">)</span>

    <span class="n">src_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">reference_image</span><span class="p">)</span>
    <span class="n">target_freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">moving_image</span><span class="p">)</span>

    <span class="c1"># Whole-pixel shift - Compute cross-correlation by an IFFT</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">src_freq</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">image_product</span> <span class="o">=</span> <span class="n">src_freq</span> <span class="o">*</span> <span class="n">target_freq</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">image_product</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
    <span class="n">image_product</span> <span class="o">/=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">image_product</span><span class="p">)</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
    <span class="n">cross_correlation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="n">image_product</span><span class="p">)</span>

    <span class="c1"># Locate maximum</span>
    <span class="n">maxima</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cross_correlation</span><span class="p">)),</span>
                              <span class="n">cross_correlation</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">midpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="n">axis_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">axis_size</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">])</span>

    <span class="n">shifts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">maxima</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">shifts</span><span class="p">[</span><span class="n">shifts</span> <span class="o">&gt;</span> <span class="n">midpoints</span><span class="p">]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="p">)[</span><span class="n">shifts</span> <span class="o">&gt;</span> <span class="n">midpoints</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">upsample_factor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_error</span><span class="p">:</span>
            <span class="n">src_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">src_freq</span> <span class="o">*</span> <span class="n">src_freq</span><span class="o">.</span><span class="n">conj</span><span class="p">()))</span>
            <span class="n">src_amp</span> <span class="o">/=</span> <span class="n">src_freq</span><span class="o">.</span><span class="n">size</span>
            <span class="n">target_amp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">target_freq</span> <span class="o">*</span> <span class="n">target_freq</span><span class="o">.</span><span class="n">conj</span><span class="p">()))</span>
            <span class="n">target_amp</span> <span class="o">/=</span> <span class="n">target_freq</span><span class="o">.</span><span class="n">size</span>
            <span class="n">CCmax</span> <span class="o">=</span> <span class="n">cross_correlation</span><span class="p">[</span><span class="n">maxima</span><span class="p">]</span>
    <span class="c1"># If upsampling &gt; 1, then refine estimate with matrix multiply DFT</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error: upsampled phase cross corrrelation not implemented here, use skimage.&#39;</span><span class="p">)</span>

    <span class="c1"># If its only one row or column the shift along that dimension has no</span>
    <span class="c1"># effect. We set to zero.</span>
    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">src_freq</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">shifts</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">return_error</span><span class="p">:</span>
        <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">CCmax</span> <span class="o">*</span> <span class="n">CCmax</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>
        <span class="n">phase_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">CCmax</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">CCmax</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">shifts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">error</span><span class="p">)),</span> <span class="n">phase_diff</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">shifts</span></div>


<div class="viewcode-block" id="phase_cross_correlation_cv"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.phase_cross_correlation_cv">[docs]</a><span class="k">def</span> <span class="nf">phase_cross_correlation_cv</span><span class="p">(</span><span class="n">reference_image</span><span class="p">,</span> <span class="n">moving_image</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute openCV to compute the phase cross correlation. It is around 16 times faster than the implementation using</span>
<span class="sd">        numpy FFT (same as skimage).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference_image : array</span>
<span class="sd">            Reference image.</span>
<span class="sd">        moving_image : array</span>
<span class="sd">            Image to register. Must be same dimensionality as</span>
<span class="sd">            ``reference_image``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        shifts : ndarray</span>
<span class="sd">            Shift vector (in pixels) required to register ``moving_image``</span>
<span class="sd">            with ``reference_image``. Axis ordering is consistent with</span>
<span class="sd">            numpy (e.g. Z, Y, X)</span>
<span class="sd">        error : float</span>
<span class="sd">            Peak response (see opencv description here:</span>
<span class="sd">            https://docs.opencv.org/4.5.3/d7/df3/group__imgproc__motion.html#ga552420a2ace9ef3fb053cd630fdb4952)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">d</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">phaseCorrelate</span><span class="p">(</span><span class="n">reference_image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">moving_image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>

        <span class="n">d_correct</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">d_correct</span></div>


<div class="viewcode-block" id="_compute_shift"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher._compute_shift">[docs]</a><span class="k">def</span> <span class="nf">_compute_shift</span><span class="p">(</span><span class="n">reference_image</span><span class="p">,</span> <span class="n">moving_image</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Backbone function to compute the registration and the registration error used for the global optimisation.</span>
<span class="sd">    This function can be replaced by experienced user to use their own registration and error estimation functions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    reference_image : array</span>
<span class="sd">        Reference image.</span>
<span class="sd">    moving_image : array</span>
<span class="sd">        Image to register. Must be same dimensionality as</span>
<span class="sd">        ``reference_image``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    d: array_like</span>
<span class="sd">        registration parameters found</span>
<span class="sd">    e: float</span>
<span class="sd">        error estimation for the registration (the higher the error the higher the registration uncertainty)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">d</span> <span class="o">=</span> <span class="n">phase_cross_correlation_cv</span><span class="p">(</span><span class="n">reference_image</span><span class="p">,</span> <span class="n">moving_image</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">max_sum_over_single_max</span><span class="p">(</span><span class="n">reference_image</span><span class="p">,</span> <span class="n">moving_image</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reference_image</span><span class="p">))</span><span class="o">*</span><span class="mi">10</span>

    <span class="k">return</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span></div>


<div class="viewcode-block" id="_get_max_proj_apr"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher._get_max_proj_apr">[docs]</a><span class="k">def</span> <span class="nf">_get_max_proj_apr</span><span class="p">(</span><span class="n">apr</span><span class="p">,</span> <span class="n">parts</span><span class="p">,</span> <span class="n">patch</span><span class="p">,</span> <span class="n">patch_yx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute maximum projection on 3D APR data.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    apr: pyapr.APR</span>
<span class="sd">        apr tree</span>
<span class="sd">    parts: pyapr.ParticlData</span>
<span class="sd">        apr particle</span>
<span class="sd">    patch: pyapr.ReconPatch</span>
<span class="sd">        patch for computing the projection only on the overlapping area.</span>
<span class="sd">    plot: bool</span>
<span class="sd">        control data plotting</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    _: list[ndarray]</span>
<span class="sd">        maximum intensity projection in each 3 dimension.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">proj</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">patch_yx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="c1"># dim=0: project along Y to produce a ZY plane</span>
            <span class="c1"># dim=1: project along X to produce a ZX plane</span>
            <span class="c1"># dim=2: project along Z to produce an YX plane</span>
            <span class="n">proj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pyapr</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">maximum_projection</span><span class="p">(</span><span class="n">apr</span><span class="p">,</span> <span class="n">parts</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">patch</span><span class="o">=</span><span class="n">patch</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">proj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pyapr</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">projection</span><span class="o">.</span><span class="n">maximum_projection</span><span class="p">(</span><span class="n">apr</span><span class="p">,</span> <span class="n">parts</span><span class="p">,</span>
                                                                  <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">patch</span><span class="o">=</span><span class="n">patch</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">))</span>
        <span class="n">proj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pyapr</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">projection</span><span class="o">.</span><span class="n">maximum_projection</span><span class="p">(</span><span class="n">apr</span><span class="p">,</span> <span class="n">parts</span><span class="p">,</span>
                                                                  <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">patch</span><span class="o">=</span><span class="n">patch</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">))</span>
        <span class="n">proj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pyapr</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">projection</span><span class="o">.</span><span class="n">maximum_projection</span><span class="p">(</span><span class="n">apr</span><span class="p">,</span> <span class="n">parts</span><span class="p">,</span>
                                                                  <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">patch</span><span class="o">=</span><span class="n">patch_yx</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">title</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;ZY&#39;</span><span class="p">,</span> <span class="s1">&#39;ZX&#39;</span><span class="p">,</span> <span class="s1">&#39;YX&#39;</span><span class="p">]):</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">proj</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">proj</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">proj</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">proj</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span></div>


<div class="viewcode-block" id="_get_proj_shifts"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher._get_proj_shifts">[docs]</a><span class="k">def</span> <span class="nf">_get_proj_shifts</span><span class="p">(</span><span class="n">proj1</span><span class="p">,</span> <span class="n">proj2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function computes shifts from max-projections on overlapping areas. It uses the phase cross-correlation</span>
<span class="sd">    to compute the shifts.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    proj1: list[ndarray]</span>
<span class="sd">        max-projections for tile 1</span>
<span class="sd">    proj2: list[ndarray]</span>
<span class="sd">        max-projections for tile 2</span>
<span class="sd">    upsample_factor: float</span>
<span class="sd">        upsampling_factor for estimating the maximum phase cross-correlation position</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    _: array_like</span>
<span class="sd">        shifts in (x, y, z) and error measure (0=reliable, 1=not reliable)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compute phase cross-correlation to extract shifts</span>
    <span class="n">dzy</span><span class="p">,</span> <span class="n">error_zy</span> <span class="o">=</span> <span class="n">_compute_shift</span><span class="p">(</span><span class="n">proj1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">proj2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">dzx</span><span class="p">,</span> <span class="n">error_zx</span> <span class="o">=</span> <span class="n">_compute_shift</span><span class="p">(</span><span class="n">proj1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">proj2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">dyx</span><span class="p">,</span> <span class="n">error_yx</span> <span class="o">=</span> <span class="n">_compute_shift</span><span class="p">(</span><span class="n">proj1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">proj2</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="c1"># Replace error == 0 with 1 otherwise the minimum spanning tree considers that vertex are not connected</span>
    <span class="k">if</span> <span class="n">error_zy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">error_zy</span> <span class="o">=</span> <span class="mf">1e-6</span>
    <span class="k">if</span> <span class="n">error_zx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">error_zx</span> <span class="o">=</span> <span class="mf">1e-6</span>
    <span class="k">if</span> <span class="n">error_yx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">error_yx</span> <span class="o">=</span> <span class="mf">1e-6</span>

    <span class="c1"># Keep only the most reliable registration</span>
    <span class="c1"># D/z</span>
    <span class="k">if</span> <span class="n">error_zx</span> <span class="o">&lt;</span> <span class="n">error_zy</span><span class="p">:</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="n">dzx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rz</span> <span class="o">=</span> <span class="n">error_zx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="n">dzy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rz</span> <span class="o">=</span> <span class="n">error_zy</span>

    <span class="c1"># H/x</span>
    <span class="k">if</span> <span class="n">error_zx</span> <span class="o">&lt;</span> <span class="n">error_yx</span><span class="p">:</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">dzx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">rx</span> <span class="o">=</span> <span class="n">error_zx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">dyx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">rx</span> <span class="o">=</span> <span class="n">error_yx</span>

    <span class="c1"># V/y</span>
    <span class="k">if</span> <span class="n">error_yx</span> <span class="o">&lt;</span> <span class="n">error_zy</span><span class="p">:</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">dyx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ry</span> <span class="o">=</span> <span class="n">error_yx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">dzy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ry</span> <span class="o">=</span> <span class="n">error_zy</span>

    <span class="c1"># for i, title, vector, err in zip(range(3), [&#39;ZY&#39;, &#39;ZX&#39;, &#39;YX&#39;], [dzy, dzx, dyx], [error_zy, error_zx, error_yx]):</span>
    <span class="c1">#     fig, ax = plt.subplots(1, 3, sharex=True, sharey=True)</span>
    <span class="c1">#     ax[0].imshow(np.log(proj1[i]+1), cmap=&#39;gray&#39;)</span>
    <span class="c1">#     ax[0].set_title(&#39;d={}, e={:0.3f}&#39;.format(vector, err))</span>
    <span class="c1">#     ax[1].imshow(np.log(proj2[i]+1), cmap=&#39;gray&#39;)</span>
    <span class="c1">#     ax[1].set_title(title)</span>
    <span class="c1">#</span>
    <span class="c1">#     shifted = warp(proj1[i], AffineTransform(translation=[vector[1], vector[0]]), mode=&#39;wrap&#39;, preserve_range=True)</span>
    <span class="c1">#     rgb = np.dstack((np.log(proj2[i]+1), np.log(shifted+1), np.zeros_like(proj1[i])))</span>
    <span class="c1">#     ax[2].imshow((rescale_intensity(rgb, out_range=&#39;uint8&#39;)).astype(&#39;uint8&#39;))</span>
    <span class="c1">#</span>
    <span class="c1"># print(&#39;ok&#39;)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dz</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dx</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rz</span><span class="p">,</span> <span class="n">ry</span><span class="p">,</span> <span class="n">rx</span><span class="p">])</span></div>


<div class="viewcode-block" id="_get_masked_proj_shifts"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher._get_masked_proj_shifts">[docs]</a><span class="k">def</span> <span class="nf">_get_masked_proj_shifts</span><span class="p">(</span><span class="n">proj1</span><span class="p">,</span> <span class="n">proj2</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">upsample_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function computes shifts from max-projections on overlapping areas with mask on brightest area.</span>
<span class="sd">    It uses the phase cross-correlation to compute the shifts.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    proj1: list[ndarray]</span>
<span class="sd">        max-projections for tile 1</span>
<span class="sd">    proj2: list[ndarray]</span>
<span class="sd">        max-projections for tile 2</span>
<span class="sd">    upsample_factor: float</span>
<span class="sd">        upsampling_factor for estimating the maximum phase cross-correlation position</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    _: array_like</span>
<span class="sd">        shifts in (x, y, z) and error measure (0=reliable, 1=not reliable)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compute mask to discard very bright area that are likely bubbles or artefacts</span>
    <span class="n">mask_ref</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">mask_move</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">proj1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">threshold</span><span class="p">)</span>
        <span class="n">mask_ref</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proj1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">proj2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">threshold</span><span class="p">)</span>
        <span class="n">mask_move</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proj2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">vmax</span><span class="p">)</span>

    <span class="c1"># Compute phase cross-correlation to extract shifts</span>
    <span class="n">dzy</span> <span class="o">=</span> <span class="n">phase_cross_correlation</span><span class="p">(</span><span class="n">proj1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">proj2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                  <span class="n">return_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">upsample_factor</span><span class="o">=</span><span class="n">upsample_factor</span><span class="p">,</span>
                                  <span class="n">reference_mask</span><span class="o">=</span><span class="n">mask_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">moving_mask</span><span class="o">=</span><span class="n">mask_move</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">error_zy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">correlate</span><span class="p">(</span><span class="n">proj1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">proj2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">proj1</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">proj2</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="n">dzx</span> <span class="o">=</span> <span class="n">phase_cross_correlation</span><span class="p">(</span><span class="n">proj1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">proj2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                  <span class="n">return_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">upsample_factor</span><span class="o">=</span><span class="n">upsample_factor</span><span class="p">,</span>
                                  <span class="n">reference_mask</span><span class="o">=</span><span class="n">mask_ref</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">moving_mask</span><span class="o">=</span><span class="n">mask_move</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">error_zx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">correlate</span><span class="p">(</span><span class="n">proj1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">proj2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">proj1</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">proj2</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="n">dyx</span> <span class="o">=</span> <span class="n">phase_cross_correlation</span><span class="p">(</span><span class="n">proj1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">proj2</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                  <span class="n">return_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">upsample_factor</span><span class="o">=</span><span class="n">upsample_factor</span><span class="p">,</span>
                                  <span class="n">reference_mask</span><span class="o">=</span><span class="n">mask_ref</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">moving_mask</span><span class="o">=</span><span class="n">mask_move</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">error_yx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">correlate</span><span class="p">(</span><span class="n">proj1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">proj2</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">proj1</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">proj2</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)))</span>

    <span class="c1"># Replace error == 0 with 1e-6 otherwise the minimum spanning tree considers that vertex are not connected</span>
    <span class="k">if</span> <span class="n">error_zy</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">error_zy</span> <span class="o">=</span> <span class="mf">1e-6</span>
    <span class="k">if</span> <span class="n">error_zx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">error_zx</span> <span class="o">=</span> <span class="mf">1e-6</span>
    <span class="k">if</span> <span class="n">error_yx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">error_yx</span> <span class="o">=</span> <span class="mf">1e-6</span>

    <span class="c1"># Keep only the most reliable registration</span>
    <span class="c1"># D/z</span>
    <span class="k">if</span> <span class="n">error_zx</span> <span class="o">&lt;</span> <span class="n">error_zy</span><span class="p">:</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="n">dzx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rz</span> <span class="o">=</span> <span class="n">error_zx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="n">dzy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">rz</span> <span class="o">=</span> <span class="n">error_zy</span>

    <span class="c1"># H/x</span>
    <span class="k">if</span> <span class="n">error_zx</span> <span class="o">&lt;</span> <span class="n">error_yx</span><span class="p">:</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">dzx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">rx</span> <span class="o">=</span> <span class="n">error_zx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">dyx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">rx</span> <span class="o">=</span> <span class="n">error_yx</span>

    <span class="c1"># V/y</span>
    <span class="k">if</span> <span class="n">error_yx</span> <span class="o">&lt;</span> <span class="n">error_zy</span><span class="p">:</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">dyx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ry</span> <span class="o">=</span> <span class="n">error_yx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">dzy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ry</span> <span class="o">=</span> <span class="n">error_zy</span>

    <span class="c1"># for i, title, vector in zip(range(3), [&#39;ZY&#39;, &#39;ZX&#39;, &#39;YX&#39;], [[dy, dz], [dx, dz], [dx, dy]]):</span>
    <span class="c1">#     fig, ax = plt.subplots(1, 3, sharex=True, sharey=True)</span>
    <span class="c1">#     ax[0].imshow(proj1[i], cmap=&#39;gray&#39;)</span>
    <span class="c1">#     ax[0].set_title(&#39;dx={}, dy={}, dz={}&#39;.format(dx, dy, dz))</span>
    <span class="c1">#     ax[1].imshow(proj2[i], cmap=&#39;gray&#39;)</span>
    <span class="c1">#     ax[1].set_title(title)</span>
    <span class="c1">#     from skimage.transform import warp, AffineTransform</span>
    <span class="c1">#     from skimage.exposure import rescale_intensity</span>
    <span class="c1">#     shifted = warp(proj1[i], AffineTransform(translation=vector), mode=&#39;wrap&#39;, preserve_range=True)</span>
    <span class="c1">#     rgb = np.dstack([proj2[i], shifted, np.zeros_like(proj1[i])])</span>
    <span class="c1">#     ax[2].imshow((rescale_intensity(rgb, out_range=&#39;uint8&#39;)).astype(&#39;uint8&#39;))</span>
    <span class="c1"># print(&#39;ok&#39;)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dz</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">dx</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rz</span><span class="p">,</span> <span class="n">ry</span><span class="p">,</span> <span class="n">rx</span><span class="p">])</span></div>


<div class="viewcode-block" id="baseStitcher"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.baseStitcher">[docs]</a><span class="k">class</span> <span class="nc">baseStitcher</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for stitching multi-tile data.</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="baseStitcher.__init__"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.baseStitcher.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">tiles</span><span class="p">,</span>
                 <span class="n">overlap_h</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="n">overlap_v</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for the baseStitcher class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tiles: tileParser</span>
<span class="sd">            tileParser object containing the dataset to stitch.</span>
<span class="sd">        overlap_h: float</span>
<span class="sd">            expected horizontal overlap in %</span>
<span class="sd">        overlap_v: float</span>
<span class="sd">            expected vertical overlap in %</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span> <span class="o">=</span> <span class="n">tiles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">tiles</span><span class="o">.</span><span class="n">ncol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nrow</span> <span class="o">=</span> <span class="n">tiles</span><span class="o">.</span><span class="n">nrow</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_vertex</span> <span class="o">=</span> <span class="n">tiles</span><span class="o">.</span><span class="n">n_tiles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_edges</span> <span class="o">=</span> <span class="n">tiles</span><span class="o">.</span><span class="n">n_edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span> <span class="o">=</span> <span class="n">tiles</span><span class="o">.</span><span class="n">frame_size</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">overlap_h</span><span class="o">/</span><span class="mi">100</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">overlap_v</span><span class="o">/</span><span class="mi">100</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">overlap_h</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span><span class="o">*</span><span class="mf">1.2</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlap_v</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span><span class="o">*</span><span class="mf">1.2</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">segment</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segmenter</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reg_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="o">*</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reg_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="o">*</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reg_z</span> <span class="o">=</span> <span class="mi">20</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">z_begin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_end</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="baseStitcher.activate_mask"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.baseStitcher.activate_mask">[docs]</a>    <span class="k">def</span> <span class="nf">activate_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Activate the masked cross-correlation for the displacement estimation. Pixels above threshold are</span>
<span class="sd">        not taken into account.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        threshold: int</span>
<span class="sd">            threshold for the cross-correlation mask as a percentage of pixel to keep (e.g. 95 will create a mask</span>
<span class="sd">            removing the 5% brightest pixels).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span></div>

<div class="viewcode-block" id="baseStitcher.deactivate_mask"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.baseStitcher.deactivate_mask">[docs]</a>    <span class="k">def</span> <span class="nf">deactivate_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deactivate the masked cross-correlation and uses a classical cross correlation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="baseStitcher.save_database"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.baseStitcher.save_database">[docs]</a>    <span class="k">def</span> <span class="nf">save_database</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save database at the given path. The database must be built before calling this method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path: string</span>
<span class="sd">            path to save the database.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: database can&#39;&#39;t be saved because it was not created. &#39;</span>
                            <span class="s1">&#39;Please call build_database() first.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;registration_results.csv&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="baseStitcher.load_database"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.baseStitcher.load_database">[docs]</a>    <span class="k">def</span> <span class="nf">load_database</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save database at the given path. The database must be built before calling this method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path: string</span>
<span class="sd">            path to save the database.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">force</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: database can&#39;&#39;t be read because a database is already exist and force is set&#39;</span>
                            <span class="s1">&#39;to False.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;registration_results.csv&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">database</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="baseStitcher.activate_segmentation"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.baseStitcher.activate_segmentation">[docs]</a>    <span class="k">def</span> <span class="nf">activate_segmentation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segmenter</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Activate the segmentation. When a tile is loaded it is segmented before the stitching is done.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        segmenter: tileSegmenter</span>
<span class="sd">            segmenter object for segmenting each tile.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segment</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segmenter</span> <span class="o">=</span> <span class="n">segmenter</span></div>

<div class="viewcode-block" id="baseStitcher.deactivate_segmentation"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.baseStitcher.deactivate_segmentation">[docs]</a>    <span class="k">def</span> <span class="nf">deactivate_segmentation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deactivate tile segmentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">segment</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="baseStitcher.reconstruct_slice"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.baseStitcher.reconstruct_slice">[docs]</a>    <span class="k">def</span> <span class="nf">reconstruct_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_proj</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">downsample</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">seg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reconstruct whole sample 2D section at the given location and in a given dimension. This function can also</span>
<span class="sd">        reconstruct a maximum intensity projection if `n_proj&gt;0`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loc: int (default: middle of the sample)</span>
<span class="sd">            Position of the plane where the reconstruction should be done. The location varies depending on the</span>
<span class="sd">            downsample parameter and should be adapted.</span>
<span class="sd">        n_proj: int (default: 0)</span>
<span class="sd">            Number of planes to perform the maximum intensity projection.</span>
<span class="sd">        dim: int (default: 0)</span>
<span class="sd">            Dimension of the reconstruction, e.g. 0 will be [y, x] plane (orthogonal to z).</span>
<span class="sd">        downsample: int (default: 1)</span>
<span class="sd">            Downsample factor for the reconstruction. Must be in [1, 2, 4, 8, 16, 32].</span>
<span class="sd">        color: bool (default: False)</span>
<span class="sd">            Option to reconstruct with checkerboard color pattern. Useful to identify doubling artifacts.</span>
<span class="sd">        debug: bool (default: False)</span>
<span class="sd">            Option to add a white square for each tile, making it easy to see overlapping areas.</span>
<span class="sd">        plot: bool (default: True)</span>
<span class="sd">            Define if the function plots the results with Matplotlib or just returns an array.</span>
<span class="sd">        seg: bool (default: False)</span>
<span class="sd">            Option to also reconstruct the segmentation. Only works with `dim=0`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        _: ndarray</span>
<span class="sd">            Array containing the reconstructed data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reconstruct_z_slice</span><span class="p">(</span><span class="n">z</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">n_proj</span><span class="o">=</span><span class="n">n_proj</span><span class="p">,</span> <span class="n">downsample</span><span class="o">=</span><span class="n">downsample</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                             <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span> <span class="n">seg</span><span class="o">=</span><span class="n">seg</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reconstruct_y_slice</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">n_proj</span><span class="o">=</span><span class="n">n_proj</span><span class="p">,</span> <span class="n">downsample</span><span class="o">=</span><span class="n">downsample</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                             <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reconstruct_x_slice</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">n_proj</span><span class="o">=</span><span class="n">n_proj</span><span class="p">,</span> <span class="n">downsample</span><span class="o">=</span><span class="n">downsample</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                             <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;dim should be in [1, 2, 3], got dim = </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="p">))</span></div>

<div class="viewcode-block" id="baseStitcher.set_regularization"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.baseStitcher.set_regularization">[docs]</a>    <span class="k">def</span> <span class="nf">set_regularization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reg_x</span><span class="p">,</span> <span class="n">reg_y</span><span class="p">,</span> <span class="n">reg_z</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the regularization for the stitching to prevent aberrant displacements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reg_x: int</span>
<span class="sd">            if the horizontal displacement computed in the pairwise registration for any tile is greater than</span>
<span class="sd">            reg_x (in pixel unit) then the expected displacement (from motor position) is taken.</span>
<span class="sd">        reg_y: int</span>
<span class="sd">            if the horizontal displacement computed in the pairwise registration for any tile is greater than</span>
<span class="sd">            reg_z (in pixel unit) then the expected displacement (from motor position) is taken.</span>
<span class="sd">        reg_z: int</span>
<span class="sd">            if the horizontal displacement computed in the pairwise registration for any tile is greater than</span>
<span class="sd">            reg_z (in pixel unit) then the expected displacement (from motor position) is taken.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reg_x</span> <span class="o">=</span> <span class="n">reg_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reg_y</span> <span class="o">=</span> <span class="n">reg_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reg_z</span> <span class="o">=</span> <span class="n">reg_z</span></div>

<div class="viewcode-block" id="baseStitcher.reconstruct_z_color"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.baseStitcher.reconstruct_z_color">[docs]</a>    <span class="k">def</span> <span class="nf">reconstruct_z_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_proj</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">downsample</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reconstruct and merge the sample at a given depth z.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        z: int</span>
<span class="sd">            reconstruction depth</span>
<span class="sd">        downsample: int</span>
<span class="sd">            downsample for reconstruction (must be a power of 2)</span>
<span class="sd">        debug: bool</span>
<span class="sd">            if true the border of each tile will be highlighted</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        merged_data: ndarray</span>
<span class="sd">            Merged frame at depth z.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">level_delta</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">downsample</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">downsample</span><span class="p">)))</span>

        <span class="n">tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">tile</span><span class="o">.</span><span class="n">lazy_load_tile</span><span class="p">(</span><span class="n">level_delta</span><span class="o">=</span><span class="n">level_delta</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error: z is too large (</span><span class="si">{}</span><span class="s1">), maximum depth at this downsample is </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="n">frame_size</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">x_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_H&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">x_pos</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">x_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="n">downsample</span> <span class="o">+</span> <span class="n">frame_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">y_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_V&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">y_pos</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">y_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="n">downsample</span> <span class="o">+</span> <span class="n">frame_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">)</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">)</span>

        <span class="n">H_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_pos</span> <span class="o">-</span> <span class="n">x_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="n">downsample</span>
        <span class="n">V_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_pos</span> <span class="o">-</span> <span class="n">y_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="n">downsample</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tile</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Merging&#39;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">progress_bar</span><span class="p">)):</span>
            <span class="n">tile</span><span class="o">.</span><span class="n">lazy_load_tile</span><span class="p">(</span><span class="n">level_delta</span><span class="o">=</span><span class="n">level_delta</span><span class="p">)</span>
            <span class="n">zf</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">z</span><span class="o">+</span><span class="n">n_proj</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="p">[</span><span class="n">z</span><span class="p">:</span><span class="n">zf</span><span class="p">]</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># In debug mode we highlight each tile edge to see where it was</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">v</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_v</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_v</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">v</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_h</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">v</span><span class="p">[:,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_h</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span>

            <span class="n">x1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">H_pos</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">H_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">V_pos</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">V_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="n">V</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">],</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">H</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">],</span> <span class="n">h</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">rescale_intensity</span><span class="p">(</span><span class="n">gaussian</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">2</span><span class="o">/</span><span class="n">downsample</span><span class="p">),</span> <span class="n">out_range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">*</span><span class="mf">0.66</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">V</span> <span class="o">+</span> <span class="mi">200</span><span class="p">)</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">V</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">100</span><span class="p">)],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">99.9</span><span class="p">))</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">rescale_intensity</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">in_range</span><span class="o">=</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">),</span> <span class="n">out_range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">rescale_intensity</span><span class="p">(</span><span class="n">V</span><span class="o">**</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">*</span><span class="mf">0.66</span>
        <span class="n">rgb</span> <span class="o">=</span> <span class="n">hsv2rgb</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">H</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">V</span><span class="p">)))</span>
        <span class="n">rgb</span> <span class="o">=</span> <span class="n">rescale_intensity</span><span class="p">(</span><span class="n">rgb</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">rgb</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;turbo&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">n_proj</span><span class="o">*</span><span class="n">downsample</span><span class="p">)</span>
            <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
            <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s1">&#39;5%&#39;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;vertical&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Depth [pixel]&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rgb</span></div>

<div class="viewcode-block" id="baseStitcher._reconstruct_z_slice"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.baseStitcher._reconstruct_z_slice">[docs]</a>    <span class="k">def</span> <span class="nf">_reconstruct_z_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_proj</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">downsample</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">seg</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reconstruct and merge the sample at a given depth z.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        z: int</span>
<span class="sd">            reconstruction depth (vary with downsample)</span>
<span class="sd">        n_proj: int (default: 0)</span>
<span class="sd">            Number of planes to perform the maximum intensity projection.</span>
<span class="sd">        dim: int (default: 0)</span>
<span class="sd">            Dimension of the reconstruction, e.g. 0 will be [y, x] plane (orthogonal to z).</span>
<span class="sd">        downsample: int (default: 1)</span>
<span class="sd">            Downsample factor for the reconstruction. Must be in [1, 2, 4, 8, 16, 32].</span>
<span class="sd">        color: bool (default: False)</span>
<span class="sd">            Option to reconstruct with checkerboard color pattern. Useful to identify doubling artifacts.</span>
<span class="sd">        debug: bool (default: False)</span>
<span class="sd">            Option to add a white square for each tile, making it easy to see overlapping areas.</span>
<span class="sd">        plot: bool (default: True)</span>
<span class="sd">            Define if the function plots the results with Matplotlib or just returns an array.</span>
<span class="sd">        seg: bool (default: False)</span>
<span class="sd">            Option to also reconstruct the segmentation. Only works with `dim=0`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        merged_data: ndarray</span>
<span class="sd">            Merged frame at depth z.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">level_delta</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">downsample</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">downsample</span><span class="p">)))</span>

        <span class="n">tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">tile</span><span class="o">.</span><span class="n">lazy_load_tile</span><span class="p">(</span><span class="n">level_delta</span><span class="o">=</span><span class="n">level_delta</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">seg</span><span class="p">:</span>
            <span class="n">tile</span><span class="o">.</span><span class="n">lazy_load_segmentation</span><span class="p">(</span><span class="n">level_delta</span><span class="o">=</span><span class="n">level_delta</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error: z is too large (</span><span class="si">{}</span><span class="s1">), maximum depth at this downsample is </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="n">frame_size</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">x_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_H&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">x_pos</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">x_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="n">downsample</span> <span class="o">+</span> <span class="n">frame_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">y_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_V&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">y_pos</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">y_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="n">downsample</span> <span class="o">+</span> <span class="n">frame_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">color</span><span class="p">:</span>
            <span class="n">merged_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">)</span>
            <span class="n">merged_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">merged_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">seg</span><span class="p">:</span>
                <span class="n">merged_seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>

        <span class="n">H_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_pos</span> <span class="o">-</span> <span class="n">x_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="n">downsample</span>
        <span class="n">V_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_pos</span> <span class="o">-</span> <span class="n">y_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="n">downsample</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tile</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Merging&#39;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">progress_bar</span><span class="p">)):</span>
            <span class="n">tile</span><span class="o">.</span><span class="n">lazy_load_tile</span><span class="p">(</span><span class="n">level_delta</span><span class="o">=</span><span class="n">level_delta</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">seg</span><span class="p">:</span>
                <span class="n">tile</span><span class="o">.</span><span class="n">lazy_load_segmentation</span><span class="p">(</span><span class="n">level_delta</span><span class="o">=</span><span class="n">level_delta</span><span class="p">)</span>
            <span class="n">zf</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">z</span><span class="o">+</span><span class="n">n_proj</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">zf</span> <span class="o">&gt;</span> <span class="n">z</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="p">[</span><span class="n">z</span><span class="p">:</span><span class="n">zf</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">seg</span><span class="p">:</span>
                    <span class="n">cc</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_segmentation</span><span class="p">[</span><span class="n">z</span><span class="p">:</span><span class="n">zf</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="p">[</span><span class="n">z</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">seg</span><span class="p">:</span>
                    <span class="n">cc</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_segmentation</span><span class="p">[</span><span class="n">z</span><span class="p">]</span>

            <span class="c1"># In debug mode we highlight each tile edge to see where it was</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">xv</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span><span class="o">/</span><span class="n">downsample</span><span class="p">)</span>
                <span class="n">xh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span><span class="o">/</span><span class="n">downsample</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="n">xv</span><span class="p">,</span> <span class="n">xh</span><span class="p">:</span><span class="o">-</span><span class="n">xh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="n">xv</span><span class="p">,</span> <span class="n">xh</span><span class="p">:</span><span class="o">-</span><span class="n">xh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">data</span><span class="p">[</span><span class="n">xv</span><span class="p">:</span><span class="o">-</span><span class="n">xv</span><span class="p">,</span> <span class="n">xh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">data</span><span class="p">[</span><span class="n">xv</span><span class="p">:</span><span class="o">-</span><span class="n">xv</span><span class="p">,</span> <span class="o">-</span><span class="n">xh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span>

            <span class="n">x1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">H_pos</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">H_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">V_pos</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">V_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">color</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">merged_data</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">merged_data</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">merged_data</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">merged_data</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">merged_data</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">seg</span><span class="p">:</span>
                    <span class="n">merged_seg</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">merged_seg</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">],</span> <span class="n">cc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">viewer</span> <span class="o">=</span> <span class="n">napari</span><span class="o">.</span><span class="n">Viewer</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">color</span><span class="p">:</span>
                <span class="n">viewer</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_process_RGB_for_display</span><span class="p">(</span><span class="n">merged_data</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Z plane&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">viewer</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_process_GRAY_for_display</span><span class="p">(</span><span class="n">merged_data</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Z plane&#39;</span><span class="p">,</span> <span class="n">contrast_limits</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">seg</span><span class="p">:</span>
                    <span class="n">viewer</span><span class="o">.</span><span class="n">add_labels</span><span class="p">(</span><span class="n">merged_seg</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Segmentation labels.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">seg</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">merged_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">merged_data</span><span class="p">,</span> <span class="n">merged_seg</span></div>

<div class="viewcode-block" id="baseStitcher._reconstruct_y_slice"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.baseStitcher._reconstruct_y_slice">[docs]</a>    <span class="k">def</span> <span class="nf">_reconstruct_y_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_proj</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">downsample</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reconstruct and merge the sample at a given position y.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y: int</span>
<span class="sd">            reconstruction location in y</span>
<span class="sd">        n_proj: int (default: 0)</span>
<span class="sd">            Number of planes to perform the maximum intensity projection.</span>
<span class="sd">        dim: int (default: 0)</span>
<span class="sd">            Dimension of the reconstruction, e.g. 0 will be [y, x] plane (orthogonal to z).</span>
<span class="sd">        downsample: int (default: 1)</span>
<span class="sd">            Downsample factor for the reconstruction. Must be in [1, 2, 4, 8, 16, 32].</span>
<span class="sd">        color: bool (default: False)</span>
<span class="sd">            Option to reconstruct with checkerboard color pattern. Useful to identify doubling artifacts.</span>
<span class="sd">        debug: bool (default: False)</span>
<span class="sd">            Option to add a white square for each tile, making it easy to see overlapping areas.</span>
<span class="sd">        plot: bool (default: True)</span>
<span class="sd">            Define if the function plots the results with Matplotlib or just returns an array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        merged_data: ndarray</span>
<span class="sd">            Merged frame at position y.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">level_delta</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">downsample</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">downsample</span><span class="p">)))</span>

        <span class="n">tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">tile</span><span class="o">.</span><span class="n">lazy_load_tile</span><span class="p">(</span><span class="n">level_delta</span><span class="o">=</span><span class="n">level_delta</span><span class="p">)</span>
        <span class="n">tile_shape</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tile_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">nrow</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">nrow</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error: y is too large (</span><span class="si">{}</span><span class="s1">), maximum depth at this downsample is </span><span class="si">{}</span><span class="s1">.&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">nrow</span><span class="p">))</span>

        <span class="n">x_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_H&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">x_pos</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">x_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="n">downsample</span> <span class="o">+</span> <span class="n">tile_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">y_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_V&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">y_pos</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">y_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="n">downsample</span> <span class="o">+</span> <span class="n">tile_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">z_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_D&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">nz</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">z_pos</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">z_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="n">downsample</span> <span class="o">+</span> <span class="n">tile_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="c1"># Determine tiles to load</span>
        <span class="n">tiles_to_load</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tiles_pos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x_loc</span><span class="p">,</span> <span class="n">y_loc</span><span class="p">,</span> <span class="n">z_loc</span><span class="p">,</span> <span class="n">tile</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x_pos</span><span class="o">/</span><span class="n">downsample</span><span class="p">,</span> <span class="n">y_pos</span><span class="o">/</span><span class="n">downsample</span><span class="p">,</span> <span class="n">z_pos</span><span class="o">/</span><span class="n">downsample</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">y_loc</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">y_loc</span><span class="o">+</span><span class="n">tile_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">tiles_to_load</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span>
                <span class="n">tiles_pos</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">z_loc</span><span class="p">,</span> <span class="n">y_loc</span><span class="p">,</span> <span class="n">x_loc</span><span class="p">])</span>
        <span class="n">tiles_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tiles_pos</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;uint64&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">color</span><span class="p">:</span>
            <span class="n">merged_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nz</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">)</span>
            <span class="n">merged_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">merged_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nz</span><span class="p">,</span> <span class="n">nx</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tile</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="n">tiles_to_load</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Merging&#39;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">progress_bar</span><span class="p">)):</span>
            <span class="n">tile</span><span class="o">.</span><span class="n">lazy_load_tile</span><span class="p">(</span><span class="n">level_delta</span><span class="o">=</span><span class="n">level_delta</span><span class="p">)</span>
            <span class="n">y_tile</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">tiles_pos</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">yf</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">y_tile</span><span class="o">+</span><span class="n">n_proj</span><span class="p">,</span> <span class="n">tiles_pos</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">yf</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="p">[:,</span> <span class="n">y_tile</span><span class="p">:</span><span class="n">yf</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="p">[:,</span> <span class="n">y_tile</span><span class="p">,</span> <span class="p">:]</span>

            <span class="c1"># In debug mode we highlight each tile edge to see where it was</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">xv</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span><span class="o">/</span><span class="n">downsample</span><span class="p">)</span>
                <span class="n">xh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span><span class="o">/</span><span class="n">downsample</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="n">xv</span><span class="p">,</span> <span class="n">xh</span><span class="p">:</span><span class="o">-</span><span class="n">xh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="n">xv</span><span class="p">,</span> <span class="n">xh</span><span class="p">:</span><span class="o">-</span><span class="n">xh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">data</span><span class="p">[</span><span class="n">xv</span><span class="p">:</span><span class="o">-</span><span class="n">xv</span><span class="p">,</span> <span class="n">xh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">data</span><span class="p">[</span><span class="n">xv</span><span class="p">:</span><span class="o">-</span><span class="n">xv</span><span class="p">,</span> <span class="o">-</span><span class="n">xh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span>


            <span class="n">x1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tiles_pos</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tiles_pos</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">z1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tiles_pos</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">z2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tiles_pos</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            
            <span class="k">if</span> <span class="n">color</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">viewer</span> <span class="o">=</span> <span class="n">napari</span><span class="o">.</span><span class="n">Viewer</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">color</span><span class="p">:</span>
                <span class="n">viewer</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_process_RGB_for_display</span><span class="p">(</span><span class="n">merged_data</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Y plane&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">viewer</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_process_GRAY_for_display</span><span class="p">(</span><span class="n">merged_data</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Y plane&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">merged_data</span></div>

<div class="viewcode-block" id="baseStitcher._reconstruct_x_slice"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.baseStitcher._reconstruct_x_slice">[docs]</a>    <span class="k">def</span> <span class="nf">_reconstruct_x_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_proj</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">downsample</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reconstruct and merge the sample at a given position x.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x: int</span>
<span class="sd">            reconstruction location in x</span>
<span class="sd">        n_proj: int (default: 0)</span>
<span class="sd">            Number of planes to perform the maximum intensity projection.</span>
<span class="sd">        dim: int (default: 0)</span>
<span class="sd">            Dimension of the reconstruction, e.g. 0 will be [y, x] plane (orthogonal to z).</span>
<span class="sd">        downsample: int (default: 1)</span>
<span class="sd">            Downsample factor for the reconstruction. Must be in [1, 2, 4, 8, 16, 32].</span>
<span class="sd">        color: bool (default: False)</span>
<span class="sd">            Option to reconstruct with checkerboard color pattern. Useful to identify doubling artifacts.</span>
<span class="sd">        debug: bool (default: False)</span>
<span class="sd">            Option to add a white square for each tile, making it easy to see overlapping areas.</span>
<span class="sd">        plot: bool (default: True)</span>
<span class="sd">            Define if the function plots the results with Matplotlib or just returns an array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        merged_data: ndarray</span>
<span class="sd">            Merged frame at position x.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">level_delta</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">downsample</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">downsample</span><span class="p">)))</span>

        <span class="n">tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">tile</span><span class="o">.</span><span class="n">lazy_load_tile</span><span class="p">(</span><span class="n">level_delta</span><span class="o">=</span><span class="n">level_delta</span><span class="p">)</span>
        <span class="n">tile_shape</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tile_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">ncol</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">ncol</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error: y is too large (</span><span class="si">{}</span><span class="s1">), maximum depth at this downsample is </span><span class="si">{}</span><span class="s1">.&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>

        <span class="n">x_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_H&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">x_pos</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">x_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="n">downsample</span> <span class="o">+</span> <span class="n">tile_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">y_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_V&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">y_pos</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">y_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="n">downsample</span> <span class="o">+</span> <span class="n">tile_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">z_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_D&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">nz</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">z_pos</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">z_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="n">downsample</span> <span class="o">+</span> <span class="n">tile_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="c1"># Determine tiles to load</span>
        <span class="n">tiles_to_load</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tiles_pos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x_loc</span><span class="p">,</span> <span class="n">y_loc</span><span class="p">,</span> <span class="n">z_loc</span><span class="p">,</span> <span class="n">tile</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x_pos</span><span class="o">/</span><span class="n">downsample</span><span class="p">,</span> <span class="n">y_pos</span><span class="o">/</span><span class="n">downsample</span><span class="p">,</span> <span class="n">z_pos</span><span class="o">/</span><span class="n">downsample</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">x_loc</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">x_loc</span><span class="o">+</span><span class="n">tile_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                <span class="n">tiles_to_load</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span>
                <span class="n">tiles_pos</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">z_loc</span><span class="p">,</span> <span class="n">y_loc</span><span class="p">,</span> <span class="n">x_loc</span><span class="p">])</span>
        <span class="n">tiles_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tiles_pos</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;uint64&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">color</span><span class="p">:</span>
            <span class="n">merged_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nz</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">)</span>
            <span class="n">merged_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">merged_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nz</span><span class="p">,</span> <span class="n">ny</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tile</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="n">tiles_to_load</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Merging&#39;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">progress_bar</span><span class="p">)):</span>
            <span class="n">tile</span><span class="o">.</span><span class="n">lazy_load_tile</span><span class="p">(</span><span class="n">level_delta</span><span class="o">=</span><span class="n">level_delta</span><span class="p">)</span>
            <span class="n">x_tile</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">tiles_pos</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">xf</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_tile</span><span class="o">+</span><span class="n">n_proj</span><span class="p">,</span> <span class="n">tiles_pos</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">xf</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">x_tile</span><span class="p">:</span><span class="n">xf</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">x_tile</span><span class="p">]</span>

            <span class="c1"># In debug mode we highlight each tile edge to see where it was</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">xv</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span><span class="o">/</span><span class="n">downsample</span><span class="p">)</span>
                <span class="n">xh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span><span class="o">/</span><span class="n">downsample</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="n">xv</span><span class="p">,</span> <span class="n">xh</span><span class="p">:</span><span class="o">-</span><span class="n">xh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="n">xv</span><span class="p">,</span> <span class="n">xh</span><span class="p">:</span><span class="o">-</span><span class="n">xh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">data</span><span class="p">[</span><span class="n">xv</span><span class="p">:</span><span class="o">-</span><span class="n">xv</span><span class="p">,</span> <span class="n">xh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">data</span><span class="p">[</span><span class="n">xv</span><span class="p">:</span><span class="o">-</span><span class="n">xv</span><span class="p">,</span> <span class="o">-</span><span class="n">xh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span>


            <span class="n">y1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tiles_pos</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tiles_pos</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">z1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tiles_pos</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">z2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tiles_pos</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            
            <span class="k">if</span> <span class="n">color</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">viewer</span> <span class="o">=</span> <span class="n">napari</span><span class="o">.</span><span class="n">Viewer</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">color</span><span class="p">:</span>
                <span class="n">viewer</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_process_RGB_for_display</span><span class="p">(</span><span class="n">merged_data</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;X plane&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">viewer</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_process_GRAY_for_display</span><span class="p">(</span><span class="n">merged_data</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;X plane&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">merged_data</span></div>

<div class="viewcode-block" id="baseStitcher._process_RGB_for_display"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.baseStitcher._process_RGB_for_display">[docs]</a>    <span class="k">def</span> <span class="nf">_process_RGB_for_display</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process RGB data for correctly displaying it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u: ndarray</span>
<span class="sd">            RGB data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data_to_display: ndarray</span>
<span class="sd">            RGB data displayable with correct contrast and colors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_to_display</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">u</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">200</span><span class="p">)</span>
            <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">200</span><span class="p">)],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">99.9</span><span class="p">))</span>
            <span class="n">data_to_display</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rescale_intensity</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">in_range</span><span class="o">=</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">),</span> <span class="n">out_range</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data_to_display</span></div>

<div class="viewcode-block" id="baseStitcher._process_GRAY_for_display"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.baseStitcher._process_GRAY_for_display">[docs]</a>    <span class="k">def</span> <span class="nf">_process_GRAY_for_display</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process RGB data for correctly displaying it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u: ndarray</span>
<span class="sd">            RGB data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data_to_display: ndarray</span>
<span class="sd">            RGB data displayable with correct contrast and colors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">u</span><span class="o">+</span><span class="mi">200</span><span class="p">)</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">u</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">200</span><span class="p">)],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">99.9</span><span class="p">))</span>
        <span class="n">data_to_display</span> <span class="o">=</span> <span class="n">rescale_intensity</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">in_range</span><span class="o">=</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">),</span> <span class="n">out_range</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data_to_display</span></div>

<div class="viewcode-block" id="baseStitcher._regularize"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.baseStitcher._regularize">[docs]</a>    <span class="k">def</span> <span class="nf">_regularize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove too large displacement and replace them with expected one with a large uncertainty.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_h</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span><span class="p">))</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg_x</span><span class="p">:</span>
            <span class="n">reg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_h</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span><span class="p">)</span>
            <span class="n">rel</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_v</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span><span class="p">))</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg_y</span><span class="p">:</span>
            <span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_v</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span><span class="p">)</span>
            <span class="n">rel</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg_z</span><span class="p">:</span>
            <span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">rel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span></div>

<div class="viewcode-block" id="baseStitcher._save_max_projs"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.baseStitcher._save_max_projs">[docs]</a>    <span class="k">def</span> <span class="nf">_save_max_projs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the computed maximum intensity projection on persistent memory. This is useful to recompute the</span>
<span class="sd">        registration directly from the max. proj. but only works if the overlaps are kept the same.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Safely create folder to save max-projs</span>
        <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">folder_max_projs</span><span class="p">)</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">):</span>
                <span class="n">proj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">proj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="n">proj</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;zy&#39;</span><span class="p">,</span> <span class="s1">&#39;zx&#39;</span><span class="p">,</span> <span class="s1">&#39;yx&#39;</span><span class="p">]):</span>
                            <span class="n">data</span> <span class="o">=</span> <span class="n">proj</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">folder_max_projs</span><span class="p">,</span>
                                                 <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">.npy&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">d</span><span class="p">)),</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span></div>

<div class="viewcode-block" id="baseStitcher._load_max_projs"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.baseStitcher._load_max_projs">[docs]</a>    <span class="k">def</span> <span class="nf">_load_max_projs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load the maximum intensity projection previously stored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path: str</span>
<span class="sd">            path to load the maximum intensity projection from. If None then default to `max_projs` folder in the</span>
<span class="sd">            acquisition folder.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">projs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">folder_max_projs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">folder_max_projs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">folder_max_projs</span> <span class="o">=</span> <span class="n">path</span>

        <span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">:</span>
            <span class="n">proj</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">ncol</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">tiles_pattern</span><span class="p">[</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># EAST 1</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;zy&#39;</span><span class="p">,</span> <span class="s1">&#39;zx&#39;</span><span class="p">,</span> <span class="s1">&#39;yx&#39;</span><span class="p">]):</span>
                        <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder_max_projs</span><span class="p">,</span>
                                                        <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_east_</span><span class="si">{}</span><span class="s1">.npy&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">d</span><span class="p">))))</span>
                    <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;east&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">tiles_pattern</span><span class="p">[</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># EAST 2</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;zy&#39;</span><span class="p">,</span> <span class="s1">&#39;zx&#39;</span><span class="p">,</span> <span class="s1">&#39;yx&#39;</span><span class="p">]):</span>
                        <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder_max_projs</span><span class="p">,</span>
                                                        <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_west_</span><span class="si">{}</span><span class="s1">.npy&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">d</span><span class="p">))))</span>
                    <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;west&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">nrow</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">tiles_pattern</span><span class="p">[</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># SOUTH 1</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;zy&#39;</span><span class="p">,</span> <span class="s1">&#39;zx&#39;</span><span class="p">,</span> <span class="s1">&#39;yx&#39;</span><span class="p">]):</span>
                        <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder_max_projs</span><span class="p">,</span>
                                                        <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_south_</span><span class="si">{}</span><span class="s1">.npy&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">d</span><span class="p">))))</span>
                    <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;south&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">tiles_pattern</span><span class="p">[</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># SOUTH 2</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;zy&#39;</span><span class="p">,</span> <span class="s1">&#39;zx&#39;</span><span class="p">,</span> <span class="s1">&#39;yx&#39;</span><span class="p">]):</span>
                        <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder_max_projs</span><span class="p">,</span>
                                                        <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_north_</span><span class="si">{}</span><span class="s1">.npy&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">d</span><span class="p">))))</span>
                    <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;north&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>

            <span class="n">projs</span><span class="p">[</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">proj</span>

        <span class="k">return</span> <span class="n">projs</span></div>

<div class="viewcode-block" id="baseStitcher._precompute_max_projs"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.baseStitcher._precompute_max_projs">[docs]</a>    <span class="k">def</span> <span class="nf">_precompute_max_projs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Precompute max-projections for loading the data only once during the stitching.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">projs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Computing max. proj.&#39;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">progress_bar</span><span class="p">):</span>
            <span class="n">tile</span><span class="o">.</span><span class="n">load_tile</span><span class="p">()</span>
            <span class="n">proj</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">ncol</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">tiles_pattern</span><span class="p">[</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># EAST 1</span>
                    <span class="n">patch</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">ReconPatch</span><span class="p">()</span>
                    <span class="n">patch</span><span class="o">.</span><span class="n">y_begin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_h</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_begin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;east&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_max_proj_apr</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">patch</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">patch_yx</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">ReconPatch</span><span class="p">()</span>
                        <span class="n">patch_yx</span><span class="o">.</span><span class="n">y_begin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_h</span>
                        <span class="n">patch_yx</span><span class="o">.</span><span class="n">z_begin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_begin</span>
                        <span class="n">patch_yx</span><span class="o">.</span><span class="n">z_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_end</span>
                        <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;east&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_max_proj_apr</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">patch</span><span class="o">=</span><span class="n">patch</span><span class="p">,</span> <span class="n">patch_yx</span><span class="o">=</span><span class="n">patch_yx</span><span class="p">,</span>
                                                              <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">tiles_pattern</span><span class="p">[</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># EAST 2</span>
                    <span class="n">patch</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">ReconPatch</span><span class="p">()</span>
                    <span class="n">patch</span><span class="o">.</span><span class="n">y_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_h</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_begin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;west&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_max_proj_apr</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">patch</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">patch_yx</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">ReconPatch</span><span class="p">()</span>
                        <span class="n">patch_yx</span><span class="o">.</span><span class="n">y_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_h</span>
                        <span class="n">patch_yx</span><span class="o">.</span><span class="n">z_begin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_begin</span>
                        <span class="n">patch_yx</span><span class="o">.</span><span class="n">z_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_end</span>
                        <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;west&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_max_proj_apr</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">patch</span><span class="o">=</span><span class="n">patch</span><span class="p">,</span> <span class="n">patch_yx</span><span class="o">=</span><span class="n">patch_yx</span><span class="p">,</span>
                                                              <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">nrow</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">tiles_pattern</span><span class="p">[</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># SOUTH 1</span>
                    <span class="n">patch</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">ReconPatch</span><span class="p">()</span>
                    <span class="n">patch</span><span class="o">.</span><span class="n">x_begin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_v</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_begin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;south&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_max_proj_apr</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">patch</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">patch_yx</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">ReconPatch</span><span class="p">()</span>
                        <span class="n">patch_yx</span><span class="o">.</span><span class="n">x_begin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_v</span>
                        <span class="n">patch_yx</span><span class="o">.</span><span class="n">z_begin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_begin</span>
                        <span class="n">patch_yx</span><span class="o">.</span><span class="n">z_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_end</span>
                        <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;south&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_max_proj_apr</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">patch</span><span class="o">=</span><span class="n">patch</span><span class="p">,</span> <span class="n">patch_yx</span><span class="o">=</span><span class="n">patch_yx</span><span class="p">,</span>
                                                               <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">tiles_pattern</span><span class="p">[</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># SOUTH 2</span>
                    <span class="n">patch</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">ReconPatch</span><span class="p">()</span>
                    <span class="n">patch</span><span class="o">.</span><span class="n">x_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_v</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_begin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;north&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_max_proj_apr</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">patch</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">patch_yx</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">ReconPatch</span><span class="p">()</span>
                        <span class="n">patch_yx</span><span class="o">.</span><span class="n">x_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_v</span>
                        <span class="n">patch_yx</span><span class="o">.</span><span class="n">z_begin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_begin</span>
                        <span class="n">patch_yx</span><span class="o">.</span><span class="n">z_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_end</span>
                        <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;north&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_max_proj_apr</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">patch</span><span class="o">=</span><span class="n">patch</span><span class="p">,</span> <span class="n">patch_yx</span><span class="o">=</span><span class="n">patch_yx</span><span class="p">,</span>
                                                               <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">projs</span><span class="p">[</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">proj</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">segment</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">segmenter</span><span class="o">.</span><span class="n">compute_segmentation</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">projs</span> <span class="o">=</span> <span class="n">projs</span></div></div>


<div class="viewcode-block" id="tileStitcher"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileStitcher">[docs]</a><span class="k">class</span> <span class="nc">tileStitcher</span><span class="p">(</span><span class="n">baseStitcher</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class used to perform the stitching. The stitching is performed in 4 steps:</span>

<span class="sd">    1. The pairwise registration parameters of each neighboring tile is computed on the max-projection</span>
<span class="sd">    2. A sparse graph (edges = tiles and vertex = registration between neighboring tiles) is constructed to store</span>
<span class="sd">       the registration parameters (displacements and reliability)</span>
<span class="sd">    3. The sparse graph is optimized to satisfy the constraints (every loop in the graph should sum to 0) using the</span>
<span class="sd">       maximum spanning tree on the reliability estimation.</span>
<span class="sd">    4. The maximum spanning tree is parsed to extract optimal tile positions solution.</span>

<span class="sd">    The beauty of this method is that it scales well with increasing dataset sizes and because the final optimization</span>
<span class="sd">    is very fast and does not require to reload the data.</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="tileStitcher.__init__"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileStitcher.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">tiles</span><span class="p">,</span>
                 <span class="n">overlap_h</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="n">overlap_v</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for the tileStitcher class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tiles: tileParser</span>
<span class="sd">            tileParser object containing the dataset to stitch.</span>
<span class="sd">        overlap_h: float</span>
<span class="sd">            expected horizontal overlap in %</span>
<span class="sd">        overlap_v: float</span>
<span class="sd">            expected vertical overlap in %</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">tiles</span><span class="p">,</span> <span class="n">overlap_h</span><span class="p">,</span> <span class="n">overlap_v</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_from</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_to</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relia_H</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relia_V</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relia_D</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dH</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dV</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dD</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Attributes below are set when the corresponding method are called.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_rel</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_abs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctree_from_H</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctree_from_V</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctree_from_D</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctree_to_H</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctree_to_V</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctree_to_D</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_tree_H</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_tree_V</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_tree_D</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_relia_H</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_relia_V</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_relia_D</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">database</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projs</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="tileStitcher._compute_registration_old"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileStitcher._compute_registration_old">[docs]</a>    <span class="k">def</span> <span class="nf">_compute_registration_old</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the pair-wise registration for all tiles. This implementation loads the data twice and is therefore</span>
<span class="sd">        not efficient.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Computing stitching&#39;</span><span class="p">):</span>
            <span class="n">tile</span><span class="o">.</span><span class="n">load_tile</span><span class="p">()</span>
            <span class="n">tile</span><span class="o">.</span><span class="n">load_neighbors</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">segment</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">segmenter</span><span class="o">.</span><span class="n">compute_segmentation</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">apr</span><span class="p">,</span> <span class="n">parts</span><span class="p">,</span> <span class="n">coords</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">apr_neighbors</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">parts_neighbors</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">neighbors</span><span class="p">):</span>

                <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">==</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span> <span class="o">&lt;</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="c1"># EAST</span>
                    <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_east_registration</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">apr</span><span class="p">,</span> <span class="n">parts</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span> <span class="o">==</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="c1"># SOUTH</span>
                    <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_south_registration</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">apr</span><span class="p">,</span> <span class="n">parts</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: couldn&#39;&#39;t determine registration to perform.&#39;</span><span class="p">)</span>

                <span class="c1"># Regularize in cas of aberrant displacements</span>
                <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_regularize</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">rel</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_from</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">([</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">],</span>
                                                                    <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">)))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_to</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                                                                  <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">)))</span>
                <span class="c1"># H=x, V=y, D=z</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dH</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dV</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dD</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">relia_H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">relia_V</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">relia_D</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_build_sparse_graphs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_sparse_graphs</span><span class="p">()</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_produce_registration_map</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_database</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_print_info</span><span class="p">()</span></div>

<div class="viewcode-block" id="tileStitcher.compute_registration"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileStitcher.compute_registration">[docs]</a>    <span class="k">def</span> <span class="nf">compute_registration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">on_disk</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the pair-wise registration for all tiles. This implementation loads the data once by precomputing</span>
<span class="sd">        the max-proj and is therefore efficient.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First we pre-compute the max-projections and keep them in memory or save them on disk and load them up.</span>
        <span class="k">if</span> <span class="n">on_disk</span><span class="p">:</span>
            <span class="c1"># It makes more sens and it avoids loading the max-proj when it is computed.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_precompute_max_projs</span><span class="p">(</span><span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_max_projs</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_precompute_max_projs</span><span class="p">(</span><span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">)</span>

        <span class="c1"># Then we loop again through the tiles but now we have access to the max-proj</span>
        <span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Computing cross-correlations&#39;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">progress_bar</span><span class="p">):</span>
            <span class="n">proj1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">[</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">coords</span> <span class="ow">in</span> <span class="n">tile</span><span class="o">.</span><span class="n">neighbors</span><span class="p">:</span>
                <span class="n">proj2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">[</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

                <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">==</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span> <span class="o">&lt;</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="c1"># EAST</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">:</span>
                        <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="n">_get_masked_proj_shifts</span><span class="p">(</span><span class="n">proj1</span><span class="p">[</span><span class="s1">&#39;east&#39;</span><span class="p">],</span> <span class="n">proj2</span><span class="p">[</span><span class="s1">&#39;west&#39;</span><span class="p">],</span> <span class="n">threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="n">_get_proj_shifts</span><span class="p">(</span><span class="n">proj1</span><span class="p">[</span><span class="s1">&#39;east&#39;</span><span class="p">],</span> <span class="n">proj2</span><span class="p">[</span><span class="s1">&#39;west&#39;</span><span class="p">])</span>

                <span class="k">elif</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span> <span class="o">==</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="c1"># SOUTH</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">:</span>
                        <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="n">_get_masked_proj_shifts</span><span class="p">(</span><span class="n">proj1</span><span class="p">[</span><span class="s1">&#39;south&#39;</span><span class="p">],</span> <span class="n">proj2</span><span class="p">[</span><span class="s1">&#39;north&#39;</span><span class="p">],</span> <span class="n">threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="n">_get_proj_shifts</span><span class="p">(</span><span class="n">proj1</span><span class="p">[</span><span class="s1">&#39;south&#39;</span><span class="p">],</span> <span class="n">proj2</span><span class="p">[</span><span class="s1">&#39;north&#39;</span><span class="p">])</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: couldn&#39;&#39;t determine registration to perform.&#39;</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_from</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">([</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">],</span>
                                                                    <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">)))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_to</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                                                                  <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">)))</span>

                <span class="c1"># Regularize in case of aberrant displacements</span>
                <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_regularize</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">rel</span><span class="p">)</span>

                <span class="c1"># H=x, V=y, D=z</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dH</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dV</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dD</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">relia_H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">relia_V</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">relia_D</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_build_sparse_graphs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_sparse_graphs</span><span class="p">()</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_produce_registration_map</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_database</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_print_info</span><span class="p">()</span></div>

<div class="viewcode-block" id="tileStitcher.compute_registration_from_max_projs"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileStitcher.compute_registration_from_max_projs">[docs]</a>    <span class="k">def</span> <span class="nf">compute_registration_from_max_projs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the registration directly from the max-projections. Max-projections must have been computed before.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># First we pre-compute the max-projections and keep them in memory or save them on disk and load them up.</span>
        <span class="n">projs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_max_projs</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">)</span>

        <span class="c1"># Then we loop again through the tiles but now we have access to the max-proj</span>
        <span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Compute cross-correlation&#39;</span><span class="p">):</span>
            <span class="n">proj1</span> <span class="o">=</span> <span class="n">projs</span><span class="p">[</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">coords</span> <span class="ow">in</span> <span class="n">tile</span><span class="o">.</span><span class="n">neighbors</span><span class="p">:</span>
                <span class="n">proj2</span> <span class="o">=</span> <span class="n">projs</span><span class="p">[</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

                <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">==</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span> <span class="o">&lt;</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="c1"># EAST</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">:</span>
                        <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="n">_get_masked_proj_shifts</span><span class="p">(</span><span class="n">proj1</span><span class="p">[</span><span class="s1">&#39;east&#39;</span><span class="p">],</span> <span class="n">proj2</span><span class="p">[</span><span class="s1">&#39;west&#39;</span><span class="p">],</span> <span class="n">threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="n">_get_proj_shifts</span><span class="p">(</span><span class="n">proj1</span><span class="p">[</span><span class="s1">&#39;east&#39;</span><span class="p">],</span> <span class="n">proj2</span><span class="p">[</span><span class="s1">&#39;west&#39;</span><span class="p">])</span>

                <span class="k">elif</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span> <span class="o">==</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="c1"># SOUTH</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">:</span>
                        <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="n">_get_masked_proj_shifts</span><span class="p">(</span><span class="n">proj1</span><span class="p">[</span><span class="s1">&#39;south&#39;</span><span class="p">],</span> <span class="n">proj2</span><span class="p">[</span><span class="s1">&#39;north&#39;</span><span class="p">],</span> <span class="n">threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="n">_get_proj_shifts</span><span class="p">(</span><span class="n">proj1</span><span class="p">[</span><span class="s1">&#39;south&#39;</span><span class="p">],</span> <span class="n">proj2</span><span class="p">[</span><span class="s1">&#39;north&#39;</span><span class="p">])</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: couldn&#39;&#39;t determine registration to perform.&#39;</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_from</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">([</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">],</span>
                                                                    <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">)))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_to</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                                                                  <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">)))</span>

                <span class="c1"># Regularize in cas of aberrant displacements</span>
                <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_regularize</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">rel</span><span class="p">)</span>

                <span class="c1"># H=x, V=y, D=z</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dH</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dV</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dD</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">relia_H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">relia_V</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">relia_D</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_build_sparse_graphs</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_sparse_graphs</span><span class="p">()</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_produce_registration_map</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_database</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_print_info</span><span class="p">()</span></div>

<div class="viewcode-block" id="tileStitcher.compute_expected_registration"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileStitcher.compute_expected_registration">[docs]</a>    <span class="k">def</span> <span class="nf">compute_expected_registration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the expected registration if the expected overlap are correct.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">reg_rel_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_rel</span> <span class="o">=</span> <span class="n">reg_rel_map</span>

        <span class="n">reg_abs_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">reg_rel_map</span><span class="p">)</span>
        <span class="c1"># H</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reg_abs_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
            <span class="n">reg_abs_map</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg_rel_map</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span><span class="p">)</span>
        <span class="c1"># V</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reg_abs_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">reg_abs_map</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">reg_rel_map</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span><span class="p">)</span>
        <span class="c1"># D</span>
        <span class="n">reg_abs_map</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg_rel_map</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_abs</span> <span class="o">=</span> <span class="n">reg_abs_map</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_build_database</span><span class="p">()</span></div>

<div class="viewcode-block" id="tileStitcher.plot_graph"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileStitcher.plot_graph">[docs]</a>    <span class="k">def</span> <span class="nf">plot_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the graph for each direction (H, D, V). This method needs to be called after the graph</span>
<span class="sd">        optimization.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        annotate: bool</span>
<span class="sd">            control if annotation are drawn on the graph</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_relia_H</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: graph not build yet, please use build_sparse_graph()&#39;</span>
                            <span class="s1">&#39;before trying to plot the graph.&#39;</span><span class="p">)</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">]):</span>
            <span class="n">ind_from</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;cgraph_from&#39;</span><span class="p">)</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">ind_from</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
            <span class="n">V1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

            <span class="n">ind_to</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;cgraph_to&#39;</span><span class="p">)</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">ind_to</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
            <span class="n">V2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

            <span class="n">rel</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;relia_&#39;</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">dX</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="s1">&#39;ko&#39;</span><span class="p">,</span> <span class="n">markerfacecolor</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">annotate</span><span class="p">:</span>
                    <span class="n">p1</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">transform_point</span><span class="p">([</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
                    <span class="n">p2</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">transform_point</span><span class="p">([</span><span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
                    <span class="n">dy</span> <span class="o">=</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">dx</span> <span class="o">=</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">dy</span><span class="p">,</span> <span class="n">dx</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">rel</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.15</span><span class="p">:</span>
                        <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;g&#39;</span>
                    <span class="k">elif</span> <span class="n">rel</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.30</span><span class="p">:</span>
                        <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;orange&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span>
                    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s1">&#39;err=</span><span class="si">{:.2f}</span><span class="s1"> d</span><span class="si">{}</span><span class="s1">=</span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">d</span><span class="p">,</span> <span class="n">dX</span><span class="p">[</span><span class="n">ii</span><span class="p">]),</span>
                                   <span class="n">xy</span><span class="o">=</span><span class="p">((</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span>
                                   <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                                   <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                                   <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                                   <span class="n">rotation</span><span class="o">=</span><span class="n">rot</span><span class="p">,</span>
                                   <span class="n">backgroundcolor</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span>
                                   <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="s1">&#39; tree&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="tileStitcher.plot_min_trees"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileStitcher.plot_min_trees">[docs]</a>    <span class="k">def</span> <span class="nf">plot_min_trees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the minimum spanning tree for each direction (H, D, V). This method needs to be called after the graph</span>
<span class="sd">        optimization.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        annotate: bool</span>
<span class="sd">            control if annotation are drawn on the graph</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_tree_H</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: minimum spanning tree not computed yet, please use optimize_sparse_graph()&#39;</span>
                            <span class="s1">&#39;before trying to plot the trees.&#39;</span><span class="p">)</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_graph</span><span class="p">(</span><span class="n">annotate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">]):</span>
            <span class="n">ind_from</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ctree_from_&#39;</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">ind_from</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
            <span class="n">V1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

            <span class="n">ind_to</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ctree_to_&#39;</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">ind_to</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
            <span class="n">V2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

            <span class="n">dX</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="s1">&#39;ko-&#39;</span><span class="p">,</span> <span class="n">markerfacecolor</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">annotate</span><span class="p">:</span>
                    <span class="n">p1</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">transform_point</span><span class="p">([</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
                    <span class="n">p2</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">transform_point</span><span class="p">([</span><span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
                    <span class="n">dy</span> <span class="o">=</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">dx</span> <span class="o">=</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">dy</span><span class="p">,</span> <span class="n">dx</span><span class="p">))</span>
                    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_ind</span><span class="p">(</span><span class="n">ind_from</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">ind_to</span><span class="p">[</span><span class="n">ii</span><span class="p">])]),</span>
                                   <span class="n">xy</span><span class="o">=</span><span class="p">((</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span>
                                   <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                                   <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                                   <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                                   <span class="n">rotation</span><span class="o">=</span><span class="n">rot</span><span class="p">,</span>
                                   <span class="n">backgroundcolor</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span>
                                   <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="s1">&#39; tree&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="tileStitcher.plot_stitching_info"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileStitcher.plot_stitching_info">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stitching_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot pair-wise registration error for each axis [H, V, D].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rel_map: array</span>
<span class="sd">            error matrix</span>
<span class="sd">        d_map: array</span>
<span class="sd">            shift matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_tree_H</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: minimum spanning tree not computed yet, please use optimize_sparse_graph()&#39;</span>
                            <span class="s1">&#39;before trying to plot stitching info.&#39;</span><span class="p">)</span>

        <span class="n">rel_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">]):</span>
            <span class="n">ind_from</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ctree_from_&#39;</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">ind_to</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ctree_to_&#39;</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;graph_relia_&#39;</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">ind_to</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">ind_from</span><span class="p">,</span> <span class="n">ind_to</span><span class="p">):</span>
                <span class="n">rel</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">]</span>
                <span class="n">rel_map</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">rel_map</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">],</span> <span class="n">rel</span><span class="p">))</span>
            <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">ind_from</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">ind_from</span><span class="p">,</span> <span class="n">ind_to</span><span class="p">):</span>
                <span class="n">rel</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">]</span>
                <span class="n">rel_map</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">rel_map</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">],</span> <span class="n">rel</span><span class="p">))</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">]):</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">rel_map</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;turbo&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Registration </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
            <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s1">&#39;5%&#39;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Estimated error [a.u.]&#39;</span><span class="p">)</span>


        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">rel_map</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;turbo&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;Total stimated error [a.u.]&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_relia_H</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: graph not build yet, please use build_sparse_graph()&#39;</span>
                            <span class="s1">&#39;before trying to plot the graph.&#39;</span><span class="p">)</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">]):</span>


            <span class="n">ind_from</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;cgraph_from&#39;</span><span class="p">)</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">ind_from</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
            <span class="n">V1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="mf">0.25</span>

            <span class="n">ind_to</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;cgraph_to&#39;</span><span class="p">)</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">ind_to</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
            <span class="n">V2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="mf">0.25</span>

            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="s1">&#39;ko&#39;</span><span class="p">,</span> <span class="n">markerfacecolor</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="s1">&#39; tree&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>

            <span class="n">ind_from</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ctree_from_&#39;</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">ind_from</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
            <span class="n">V1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="mf">0.25</span>

            <span class="n">ind_to</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ctree_to_&#39;</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">ind_to</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
            <span class="n">V2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="mf">0.25</span>

            <span class="n">dX</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="s1">&#39;ko-&#39;</span><span class="p">,</span> <span class="n">markerfacecolor</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">transform_point</span><span class="p">([</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">transform_point</span><span class="p">([</span><span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
                <span class="n">dy</span> <span class="o">=</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">dy</span><span class="p">,</span> <span class="n">dx</span><span class="p">))</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_ind</span><span class="p">(</span><span class="n">ind_from</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">ind_to</span><span class="p">[</span><span class="n">ii</span><span class="p">])]),</span>
                               <span class="n">xy</span><span class="o">=</span><span class="p">((</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
                               <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                               <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                               <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                               <span class="n">rotation</span><span class="o">=</span><span class="n">rot</span><span class="p">,</span>
                               <span class="n">backgroundcolor</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span>
                               <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>

            <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">registration_map_rel</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">annot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;4.0f&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="tileStitcher.plot_registration_map"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileStitcher.plot_registration_map">[docs]</a>    <span class="k">def</span> <span class="nf">plot_registration_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display the registration map using matplotlib.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_abs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: registration map not computed yet, please use produce_registration_map()&#39;</span>
                            <span class="s1">&#39;before trying to display the registration map.&#39;</span><span class="p">)</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">]):</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">registration_map_rel</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Rel reg. map &#39;</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">registration_map_abs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Abs reg. map &#39;</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span></div>

<div class="viewcode-block" id="tileStitcher.dump_stitcher"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileStitcher.dump_stitcher">[docs]</a>    <span class="k">def</span> <span class="nf">dump_stitcher</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use dill to store a tgraph object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path: string</span>
<span class="sd">            path to save the database.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">!=</span> <span class="s1">&#39;.pkl&#39;</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="s1">&#39;.pkl&#39;</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">dill</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span></div>

<div class="viewcode-block" id="tileStitcher.set_overlap_margin"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileStitcher.set_overlap_margin">[docs]</a>    <span class="k">def</span> <span class="nf">set_overlap_margin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">margin</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modify the overlaping area size. If the overlaping area is smaller than the true one, the stitching can&#39;t</span>
<span class="sd">        be performed properly. If the overlaping area area is more than twice the size of the true one it will also</span>
<span class="sd">        fail (due to the circular FFT in the phase cross correlation).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        margin: float</span>
<span class="sd">            safety margin in % to take the overlaping area.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">margin</span> <span class="o">&gt;</span> <span class="mi">45</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error: overlap margin is too big and will make the stitching fail.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">margin</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error: overlap margin is too small and may make the stitching fail.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">overlap_h</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">margin</span><span class="o">/</span><span class="mi">100</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlap_v</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">margin</span><span class="o">/</span><span class="mi">100</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span></div>

<div class="viewcode-block" id="tileStitcher.set_z_range"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileStitcher.set_z_range">[docs]</a>    <span class="k">def</span> <span class="nf">set_z_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z_begin</span><span class="p">,</span> <span class="n">z_end</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a range of depth fo computing the stitching.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        z_begin: int</span>
<span class="sd">            first depth to be included in the max-proj</span>
<span class="sd">        z_end: int</span>
<span class="sd">            last depth to be included in the max-proj</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">z_begin</span> <span class="o">=</span> <span class="n">z_begin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_end</span> <span class="o">=</span> <span class="n">z_end</span></div>

<div class="viewcode-block" id="tileStitcher._print_info"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileStitcher._print_info">[docs]</a>    <span class="k">def</span> <span class="nf">_print_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display stitching result information.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">registration_map_abs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">effective_overlap_h</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="o">-</span><span class="n">overlap</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="o">*</span><span class="mi">100</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Effective horizontal overlap: </span><span class="si">{:0.2f}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">effective_overlap_h</span><span class="p">))</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">registration_map_abs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">effective_overlap_v</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="o">-</span><span class="n">overlap</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="o">*</span><span class="mi">100</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Effective vertical overlap: </span><span class="si">{:0.2f}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">effective_overlap_v</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">effective_overlap_v</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="o">/</span><span class="mi">100</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span><span class="p">)</span><span class="o">&gt;</span><span class="mf">0.2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Expected vertical overlap is very different from the computed one, the registration &#39;</span>
                          <span class="s1">&#39;might be wrong.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">effective_overlap_h</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="o">/</span><span class="mi">100</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span><span class="p">)</span><span class="o">&gt;</span><span class="mf">0.2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Expected horizontal overlap is very different from the computed one, the registration &#39;</span>
                          <span class="s1">&#39;might be wrong.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="tileStitcher._build_sparse_graphs"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileStitcher._build_sparse_graphs">[docs]</a>    <span class="k">def</span> <span class="nf">_build_sparse_graphs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the sparse graph from the reliability and (row, col). This method needs to be called after the</span>
<span class="sd">        pair-wise registration has been performed for all neighbors pair.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">csr_matrix_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_relia_H</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">relia_H</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cgraph_from</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_to</span><span class="p">)),</span>
                                        <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">csr_matrix_size</span><span class="p">,</span> <span class="n">csr_matrix_size</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_relia_V</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">relia_V</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cgraph_from</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_to</span><span class="p">)),</span>
                                        <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">csr_matrix_size</span><span class="p">,</span> <span class="n">csr_matrix_size</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_relia_D</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">relia_D</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cgraph_from</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_to</span><span class="p">)),</span>
                                        <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">csr_matrix_size</span><span class="p">,</span> <span class="n">csr_matrix_size</span><span class="p">))</span></div>

<div class="viewcode-block" id="tileStitcher._optimize_sparse_graphs"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileStitcher._optimize_sparse_graphs">[docs]</a>    <span class="k">def</span> <span class="nf">_optimize_sparse_graphs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimize the sparse graph by computing the minimum spanning tree for each direction (H, D, V). This</span>
<span class="sd">        method needs to be called after the sparse graphs have been built.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_relia_H</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: sparse graph not build yet, please use build_sparse_graph() before trying to&#39;</span>
                            <span class="s1">&#39;perform the optimization.&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;graph_relia_H&#39;</span><span class="p">,</span> <span class="s1">&#39;graph_relia_V&#39;</span><span class="p">,</span> <span class="s1">&#39;graph_relia_D&#39;</span><span class="p">]:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
            <span class="c1"># Minimum spanning tree</span>
            <span class="n">min_tree</span> <span class="o">=</span> <span class="n">minimum_spanning_tree</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

            <span class="c1"># Get the &quot;true&quot; neighbors</span>
            <span class="n">min_tree</span> <span class="o">=</span> <span class="n">min_tree</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;min_tree_&#39;</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">min_tree</span><span class="p">)</span>
            <span class="n">ctree_from</span> <span class="o">=</span> <span class="n">min_tree</span><span class="o">.</span><span class="n">row</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ctree_from_&#39;</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ctree_from</span><span class="p">)</span>

            <span class="n">ctree_to</span> <span class="o">=</span> <span class="n">min_tree</span><span class="o">.</span><span class="n">col</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ctree_to_&#39;</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ctree_to</span><span class="p">)</span></div>

<div class="viewcode-block" id="tileStitcher._produce_registration_map"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileStitcher._produce_registration_map">[docs]</a>    <span class="k">def</span> <span class="nf">_produce_registration_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produce the registration map where reg_rel_map[d, row, col] (d = H,V,D) is the relative tile</span>
<span class="sd">        position in pixel from the expected one. This method needs to be called after the optimization has been done.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_tree_H</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: minimum spanning tree not computed yet, please use optimize_sparse_graph()&#39;</span>
                            <span class="s1">&#39;before trying to compute the registration map.&#39;</span><span class="p">)</span>

        <span class="c1"># Relative registration</span>
        <span class="c1"># Initialize relative registration map</span>
        <span class="n">reg_rel_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span> <span class="c1"># H, V, D</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">min_tree</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;min_tree_H&#39;</span><span class="p">,</span> <span class="s1">&#39;min_tree_V&#39;</span><span class="p">,</span> <span class="s1">&#39;min_tree_D&#39;</span><span class="p">]):</span>
            <span class="c1"># Fill it by following the tree and getting the corresponding registration parameters</span>
            <span class="n">node_array</span> <span class="o">=</span> <span class="n">depth_first_order</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_tree</span><span class="p">),</span> <span class="n">i_start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cgraph_from</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                           <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_predecessors</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">node_visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="n">tree</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_tree</span><span class="p">)</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">row</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">col</span>

            <span class="k">for</span> <span class="n">node_to</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node_array</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="c1"># The previous node in the MST is a visited node with an edge to the current node</span>
                <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="n">node_to</span><span class="p">:</span>
                        <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">node_to</span><span class="p">:</span>
                        <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="n">node_from</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">neighbors</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node_visited</span><span class="p">]</span>
                <span class="n">node_visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_to</span><span class="p">)</span>

                <span class="c1"># Get the previous neighbor local reg parameter</span>
                <span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">node_from</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
                <span class="n">d_neighbor</span> <span class="o">=</span> <span class="n">reg_rel_map</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">]</span>

                <span class="c1"># Get the current 2D tile position</span>
                <span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">node_to</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
                <span class="c1"># Get the associated ind position in the registration graph (as opposed to the reliability min_tree)</span>
                <span class="n">ind_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ind</span><span class="p">(</span><span class="n">node_from</span><span class="p">,</span> <span class="n">node_to</span><span class="p">)</span>
                <span class="c1"># Get the corresponding reg parameter</span>
                <span class="n">d</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span> <span class="o">+</span> <span class="n">min_tree</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="n">ind_graph</span><span class="p">]</span>
                <span class="c1"># Get the corresponding relia and print a warning if it was regularized:</span>
                <span class="n">relia</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;relia_&#39;</span> <span class="o">+</span> <span class="n">min_tree</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="n">ind_graph</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">relia</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Aberrant pair-wise registration remaining after global optimization between tile (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">) &#39;</span>
                          <span class="s1">&#39;and tile (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">node_from</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">)),</span>
                                                    <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">node_to</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))))</span>
                <span class="c1"># Update the local reg parameter in the 2D matrix</span>
                <span class="k">if</span> <span class="n">node_to</span> <span class="o">&gt;</span> <span class="n">node_from</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">reg_rel_map</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_neighbor</span> <span class="o">+</span> <span class="n">d</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">reg_rel_map</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_neighbor</span> <span class="o">-</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_rel</span> <span class="o">=</span> <span class="n">reg_rel_map</span>

        <span class="n">reg_abs_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">reg_rel_map</span><span class="p">)</span>
        <span class="c1"># H</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reg_abs_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
            <span class="n">reg_abs_map</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg_rel_map</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_h</span><span class="p">)</span>
        <span class="c1"># V</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reg_abs_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">reg_abs_map</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">reg_rel_map</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_v</span><span class="p">)</span>
        <span class="c1"># D</span>
        <span class="n">reg_abs_map</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg_rel_map</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_abs</span> <span class="o">=</span> <span class="n">reg_abs_map</span>

        <span class="k">return</span> <span class="n">reg_rel_map</span><span class="p">,</span> <span class="n">reg_abs_map</span></div>

<div class="viewcode-block" id="tileStitcher._build_database"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileStitcher._build_database">[docs]</a>    <span class="k">def</span> <span class="nf">_build_database</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the database for storing the registration parameters. This method needs to be called after</span>
<span class="sd">        the registration map has been produced.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_rel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: database can&#39;&#39;t be build if the registration map has not been computed.&#39;</span>
                            <span class="s1">&#39; Please use produce_registration_map() method first.&#39;</span><span class="p">)</span>

        <span class="n">database_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_vertex</span><span class="p">):</span>
            <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">row</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">col</span>
            <span class="n">database_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
                                <span class="s1">&#39;row&#39;</span><span class="p">:</span> <span class="n">row</span><span class="p">,</span>
                                <span class="s1">&#39;col&#39;</span><span class="p">:</span> <span class="n">col</span><span class="p">,</span>
                                <span class="s1">&#39;dH&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_rel</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">],</span>
                                <span class="s1">&#39;dV&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_rel</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">],</span>
                                <span class="s1">&#39;dD&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_rel</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">],</span>
                                <span class="s1">&#39;ABS_H&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_abs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">],</span>
                                <span class="s1">&#39;ABS_V&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_abs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">],</span>
                                <span class="s1">&#39;ABS_D&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_abs</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">database</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">database_dict</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>

        <span class="c1"># Finally set the origin so that tile on the edge have coordinate 0 (rather than negative):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;ABS_D&#39;</span><span class="p">,</span> <span class="s1">&#39;ABS_V&#39;</span><span class="p">,</span> <span class="s1">&#39;ABS_H&#39;</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span></div>

<div class="viewcode-block" id="tileStitcher._get_ind"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileStitcher._get_ind">[docs]</a>    <span class="k">def</span> <span class="nf">_get_ind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind_from</span><span class="p">,</span> <span class="n">ind_to</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the ind in the original graph which corresponds to (ind_from, ind_to) in the minimum spanning tree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ind_from: int</span>
<span class="sd">            starting node in the directed graph</span>
<span class="sd">        ind_to: int</span>
<span class="sd">            ending node in the directed graph</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        ind: int</span>
<span class="sd">            corresponding ind in the original graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cgraph_from</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="n">ind_from</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_to</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">ind_to</span><span class="p">:</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">ind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cgraph_to</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="n">ind_from</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_from</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">ind_to</span><span class="p">:</span>
                        <span class="n">ind</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">ind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error: can&#39;&#39;t find matching vertex pair.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ind</span></div>

<div class="viewcode-block" id="tileStitcher._compute_east_registration"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileStitcher._compute_east_registration">[docs]</a>    <span class="k">def</span> <span class="nf">_compute_east_registration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apr_1</span><span class="p">,</span> <span class="n">parts_1</span><span class="p">,</span> <span class="n">apr_2</span><span class="p">,</span> <span class="n">parts_2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the registration between the current tile and its eastern neighbor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u: list</span>
<span class="sd">            current tile</span>
<span class="sd">        v: list</span>
<span class="sd">            neighboring tile</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">patch</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">ReconPatch</span><span class="p">()</span>
        <span class="n">patch</span><span class="o">.</span><span class="n">y_begin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_h</span>
        <span class="n">proj_zy1</span><span class="p">,</span> <span class="n">proj_zx1</span><span class="p">,</span> <span class="n">proj_yx1</span> <span class="o">=</span> <span class="n">_get_max_proj_apr</span><span class="p">(</span><span class="n">apr_1</span><span class="p">,</span> <span class="n">parts_1</span><span class="p">,</span> <span class="n">patch</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">patch</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">ReconPatch</span><span class="p">()</span>
        <span class="n">patch</span><span class="o">.</span><span class="n">y_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_h</span>
        <span class="n">proj_zy2</span><span class="p">,</span> <span class="n">proj_zx2</span><span class="p">,</span> <span class="n">proj_yx2</span> <span class="o">=</span> <span class="n">_get_max_proj_apr</span><span class="p">(</span><span class="n">apr_2</span><span class="p">,</span> <span class="n">parts_2</span><span class="p">,</span> <span class="n">patch</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># proj1, proj2 = [proj_zy1, proj_zx1, proj_yx1], [proj_zy2, proj_zx2, proj_yx2]</span>
        <span class="c1"># for i, title in enumerate([&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;]):</span>
        <span class="c1">#     fig, ax = plt.subplots(1, 2, sharex=True, sharey=True)</span>
        <span class="c1">#     ax[0].imshow(proj1[i], cmap=&#39;gray&#39;)</span>
        <span class="c1">#     ax[0].set_title(&#39;EAST&#39;)</span>
        <span class="c1">#     ax[1].imshow(proj2[i], cmap=&#39;gray&#39;)</span>
        <span class="c1">#     ax[1].set_title(title)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_get_masked_proj_shifts</span><span class="p">([</span><span class="n">proj_zy1</span><span class="p">,</span> <span class="n">proj_zx1</span><span class="p">,</span> <span class="n">proj_yx1</span><span class="p">],</span>
                                           <span class="p">[</span><span class="n">proj_zy2</span><span class="p">,</span> <span class="n">proj_zx2</span><span class="p">,</span> <span class="n">proj_yx2</span><span class="p">],</span>
                                           <span class="n">threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_get_proj_shifts</span><span class="p">([</span><span class="n">proj_zy1</span><span class="p">,</span> <span class="n">proj_zx1</span><span class="p">,</span> <span class="n">proj_yx1</span><span class="p">],</span>
                                    <span class="p">[</span><span class="n">proj_zy2</span><span class="p">,</span> <span class="n">proj_zx2</span><span class="p">,</span> <span class="n">proj_yx2</span><span class="p">])</span></div>

<div class="viewcode-block" id="tileStitcher._compute_south_registration"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileStitcher._compute_south_registration">[docs]</a>    <span class="k">def</span> <span class="nf">_compute_south_registration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apr_1</span><span class="p">,</span> <span class="n">parts_1</span><span class="p">,</span> <span class="n">apr_2</span><span class="p">,</span> <span class="n">parts_2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the registration between the current tile and its southern neighbor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u: list</span>
<span class="sd">            current tile</span>
<span class="sd">        v: list</span>
<span class="sd">            neighboring tile</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">patch</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">ReconPatch</span><span class="p">()</span>
        <span class="n">patch</span><span class="o">.</span><span class="n">x_begin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_v</span>
        <span class="n">proj_zy1</span><span class="p">,</span> <span class="n">proj_zx1</span><span class="p">,</span> <span class="n">proj_yx1</span> <span class="o">=</span> <span class="n">_get_max_proj_apr</span><span class="p">(</span><span class="n">apr_1</span><span class="p">,</span> <span class="n">parts_1</span><span class="p">,</span> <span class="n">patch</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">patch</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">ReconPatch</span><span class="p">()</span>
        <span class="n">patch</span><span class="o">.</span><span class="n">x_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_v</span>
        <span class="n">proj_zy2</span><span class="p">,</span> <span class="n">proj_zx2</span><span class="p">,</span> <span class="n">proj_yx2</span> <span class="o">=</span> <span class="n">_get_max_proj_apr</span><span class="p">(</span><span class="n">apr_2</span><span class="p">,</span> <span class="n">parts_2</span><span class="p">,</span> <span class="n">patch</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># proj1, proj2 = [proj_zy1, proj_zx1, proj_yx1], [proj_zy2, proj_zx2, proj_yx2]</span>
        <span class="c1"># for i, title in enumerate([&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;]):</span>
        <span class="c1">#     fig, ax = plt.subplots(1, 2, sharex=True, sharey=True)</span>
        <span class="c1">#     ax[0].imshow(proj1[i], cmap=&#39;gray&#39;)</span>
        <span class="c1">#     ax[0].set_title(&#39;SOUTH&#39;)</span>
        <span class="c1">#     ax[1].imshow(proj2[i], cmap=&#39;gray&#39;)</span>
        <span class="c1">#     ax[1].set_title(title)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_get_masked_proj_shifts</span><span class="p">([</span><span class="n">proj_zy1</span><span class="p">,</span> <span class="n">proj_zx1</span><span class="p">,</span> <span class="n">proj_yx1</span><span class="p">],</span>
                                           <span class="p">[</span><span class="n">proj_zy2</span><span class="p">,</span> <span class="n">proj_zx2</span><span class="p">,</span> <span class="n">proj_yx2</span><span class="p">],</span>
                                           <span class="n">threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_get_proj_shifts</span><span class="p">([</span><span class="n">proj_zy1</span><span class="p">,</span> <span class="n">proj_zx1</span><span class="p">,</span> <span class="n">proj_yx1</span><span class="p">],</span>
                                    <span class="p">[</span><span class="n">proj_zy2</span><span class="p">,</span> <span class="n">proj_zx2</span><span class="p">,</span> <span class="n">proj_yx2</span><span class="p">])</span></div></div>


<div class="viewcode-block" id="channelStitcher"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.channelStitcher">[docs]</a><span class="k">class</span> <span class="nc">channelStitcher</span><span class="p">(</span><span class="n">baseStitcher</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class used to perform the stitching between different channels. The registration must be performed first a single</span>
<span class="sd">    channel (typically auto-fluorescence)</span>

<span class="sd">    The stitching is performed between each corresponding tile and the relative displacement is added to the previously</span>
<span class="sd">    determined stitching parameters.</span>

<span class="sd">    The number and position of tile should matched for bot dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="channelStitcher.__init__"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.channelStitcher.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">stitcher</span><span class="p">,</span>
                 <span class="n">ref</span><span class="p">,</span>
                 <span class="n">moving</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for the channelStitcher class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stitcher: tileStitcher</span>
<span class="sd">            tileStitcher object with the multitile registration parameters</span>
<span class="sd">        tiles_stitched: tileParser</span>
<span class="sd">            tiles corresponding to the stitcher</span>
<span class="sd">        tiles_channel: tileParser</span>
<span class="sd">            tiles to be registered to tiles_stitched</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">moving</span><span class="p">,</span>
                         <span class="n">stitcher</span><span class="o">.</span><span class="n">overlap_h</span><span class="p">,</span>
                         <span class="n">stitcher</span><span class="o">.</span><span class="n">overlap_v</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stitcher</span> <span class="o">=</span> <span class="n">stitcher</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tiles_ref</span> <span class="o">=</span> <span class="n">ref</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">database</span> <span class="o">=</span> <span class="n">stitcher</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Change tiles path for the channel tiles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">path_list</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">segment</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segmentation_verbose</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">patch</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">ReconPatch</span><span class="p">()</span></div>

<div class="viewcode-block" id="channelStitcher.compute_rigid_registration"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.channelStitcher.compute_rigid_registration">[docs]</a>    <span class="k">def</span> <span class="nf">compute_rigid_registration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the rigid registration between each pair of tiles across different channels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">tile1</span><span class="p">,</span> <span class="n">tile2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiles_ref</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Computing rigid registration&#39;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">progress_bar</span><span class="p">),</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">):</span>

            <span class="n">tile1</span><span class="o">.</span><span class="n">load_tile</span><span class="p">()</span>
            <span class="n">tile2</span><span class="o">.</span><span class="n">load_tile</span><span class="p">()</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">segment</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">segmenter</span><span class="o">.</span><span class="n">compute_segmentation</span><span class="p">(</span><span class="n">tile2</span><span class="p">)</span>

            <span class="n">proj1</span> <span class="o">=</span> <span class="n">_get_max_proj_apr</span><span class="p">(</span><span class="n">tile1</span><span class="o">.</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile1</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="p">)</span>
            <span class="n">proj2</span> <span class="o">=</span> <span class="n">_get_max_proj_apr</span><span class="p">(</span><span class="n">tile2</span><span class="o">.</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile2</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">:</span>
                <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="n">_get_masked_proj_shifts</span><span class="p">(</span><span class="n">proj1</span><span class="p">,</span> <span class="n">proj2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="n">_get_proj_shifts</span><span class="p">(</span><span class="n">proj1</span><span class="p">,</span> <span class="n">proj2</span><span class="p">)</span>

            <span class="c1"># TODO: add regularization to avoid aberrant shifts.</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_update_database</span><span class="p">(</span><span class="n">tile2</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile2</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">reg</span><span class="p">)</span></div>

<div class="viewcode-block" id="channelStitcher.set_lim"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.channelStitcher.set_lim">[docs]</a>    <span class="k">def</span> <span class="nf">set_lim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_begin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x_end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y_begin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y_end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z_begin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z_end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define spatial limits to compute the maximum intensity projection.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_begin: int</span>
<span class="sd">        x_end: int</span>
<span class="sd">        y_begin: int</span>
<span class="sd">        y_end: int</span>
<span class="sd">        z_begin: int</span>
<span class="sd">        z_end: int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">x_begin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">x_begin</span> <span class="o">=</span> <span class="n">x_begin</span>
        <span class="k">if</span> <span class="n">x_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">x_end</span> <span class="o">=</span> <span class="n">x_end</span>
        <span class="k">if</span> <span class="n">y_begin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">y_begin</span> <span class="o">=</span> <span class="n">y_begin</span>
        <span class="k">if</span> <span class="n">y_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">y_end</span> <span class="o">=</span> <span class="n">y_end</span>
        <span class="k">if</span> <span class="n">z_begin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">z_begin</span> <span class="o">=</span> <span class="n">z_begin</span>
        <span class="k">if</span> <span class="n">z_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="o">.</span><span class="n">z_end</span> <span class="o">=</span> <span class="n">z_end</span></div>

<div class="viewcode-block" id="channelStitcher._update_database"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.channelStitcher._update_database">[docs]</a>    <span class="k">def</span> <span class="nf">_update_database</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update database after the registration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        row: int</span>
<span class="sd">            row number</span>
<span class="sd">        col: int</span>
<span class="sd">            col number</span>
<span class="sd">        d: int</span>
<span class="sd">            computed displacement</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span>
        <span class="k">for</span> <span class="n">loc</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="s1">&#39;dD&#39;</span><span class="p">,</span> <span class="s1">&#39;dV&#39;</span><span class="p">,</span> <span class="s1">&#39;dH&#39;</span><span class="p">,</span> <span class="s1">&#39;ABS_D&#39;</span><span class="p">,</span> <span class="s1">&#39;ABS_V&#39;</span><span class="p">,</span> <span class="s1">&#39;ABS_H&#39;</span><span class="p">],</span> <span class="n">d</span><span class="p">):</span>
            <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;row&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">row</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;col&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">col</span><span class="p">),</span> <span class="n">loc</span><span class="p">]</span> <span class="o">+=</span> <span class="n">value</span></div></div>


<div class="viewcode-block" id="tileMerger"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileMerger">[docs]</a><span class="k">class</span> <span class="nc">tileMerger</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to merge tiles and create a stitched volume. Typically used at a lower resolution for registering</span>
<span class="sd">    the sample to an Atlas.</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="tileMerger.__init__"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileMerger.__init__">[docs]</a>    <span class="k">def</span>     <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tiles</span><span class="p">,</span> <span class="n">database</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for the tileMerger class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tiles:  tileParser</span>
<span class="sd">            tileParser object containing the dataset to merge.</span>
<span class="sd">        database: (pd.DataFrame, string)</span>
<span class="sd">            database or path to the database containing the registered tile position</span>
<span class="sd">        n_planes: int</span>
<span class="sd">            number of planes per files.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">database</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">database</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">database</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">database</span> <span class="o">=</span> <span class="n">database</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span> <span class="o">=</span> <span class="n">tiles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lazy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_if_lazy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">tiles</span><span class="o">.</span><span class="n">type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span> <span class="o">=</span> <span class="n">tiles</span><span class="o">.</span><span class="n">frame_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_planes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_n_planes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span> <span class="o">=</span> <span class="n">tiles</span><span class="o">.</span><span class="n">n_tiles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_row</span> <span class="o">=</span> <span class="n">tiles</span><span class="o">.</span><span class="n">nrow</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_col</span> <span class="o">=</span> <span class="n">tiles</span><span class="o">.</span><span class="n">ncol</span>

        <span class="c1"># Size of the merged array (to be defined when the merged array is initialized).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ny</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nz</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">level_delta</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">merged_segmentation</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="tileMerger.merge_additive"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileMerger.merge_additive">[docs]</a>    <span class="k">def</span> <span class="nf">merge_additive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reconstruction_mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">tree_mode</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform merging with a mean algorithm for overlapping areas. Maximum merging should be preferred to</span>
<span class="sd">        avoid integer overflowing and higher signals on the overlapping areas.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode: string</span>
<span class="sd">            APR reconstruction type among (&#39;constant&#39;, &#39;smooth&#39;, &#39;level&#39;)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_merged_array</span><span class="p">()</span>

        <span class="n">H_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_H&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">H_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">H_pos</span> <span class="o">-</span> <span class="n">H_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">downsample</span>
        <span class="n">V_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_V&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">V_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">V_pos</span> <span class="o">-</span> <span class="n">V_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">downsample</span>
        <span class="n">D_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_D&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">D_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">D_pos</span> <span class="o">-</span> <span class="n">D_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">downsample</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tile</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Merging&#39;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">progress_bar</span><span class="p">)):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;apr&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lazy</span><span class="p">:</span>
                    <span class="n">tile</span><span class="o">.</span><span class="n">lazy_load_tile</span><span class="p">(</span><span class="n">level_delta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">level_delta</span><span class="p">)</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tile</span><span class="o">.</span><span class="n">load_tile</span><span class="p">()</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">reconstruction</span><span class="o">.</span><span class="n">APRSlicer</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">level_delta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">level_delta</span><span class="p">,</span>
                                                        <span class="n">mode</span><span class="o">=</span><span class="n">reconstruction_mode</span><span class="p">,</span> <span class="n">tree_mode</span><span class="o">=</span><span class="n">tree_mode</span><span class="p">)</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tile</span><span class="o">.</span><span class="n">load_tile</span><span class="p">()</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">data</span>

            <span class="n">x1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">H_pos</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">H_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">V_pos</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">V_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">z1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">D_pos</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">z2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">D_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;uint16&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="tileMerger.merge_max"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileMerger.merge_max">[docs]</a>    <span class="k">def</span> <span class="nf">merge_max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reconstruction_mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">tree_mode</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform merging with a maximum algorithm for overlapping areas.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode: string</span>
<span class="sd">            APR reconstruction type among (&#39;constant&#39;, &#39;smooth&#39;, &#39;level&#39;)</span>
<span class="sd">        debug: bool</span>
<span class="sd">            add white border on the edge of each tile to see where it was overlapping.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_merged_array</span><span class="p">()</span>

        <span class="n">H_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_H&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">H_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">H_pos</span> <span class="o">-</span> <span class="n">H_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">downsample</span>
        <span class="n">V_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_V&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">V_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">V_pos</span> <span class="o">-</span> <span class="n">V_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">downsample</span>
        <span class="n">D_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_D&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">D_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">D_pos</span> <span class="o">-</span> <span class="n">D_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">downsample</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tile</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Merging&#39;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">progress_bar</span><span class="p">)):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;apr&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lazy</span><span class="p">:</span>
                    <span class="n">tile</span><span class="o">.</span><span class="n">lazy_load_tile</span><span class="p">(</span><span class="n">level_delta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">level_delta</span><span class="p">)</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tile</span><span class="o">.</span><span class="n">load_tile</span><span class="p">()</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">reconstruction</span><span class="o">.</span><span class="n">APRSlicer</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">level_delta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">level_delta</span><span class="p">,</span>
                                                        <span class="n">mode</span><span class="o">=</span><span class="n">reconstruction_mode</span><span class="p">,</span> <span class="n">tree_mode</span><span class="o">=</span><span class="n">tree_mode</span><span class="p">)</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tile</span><span class="o">.</span><span class="n">load_tile</span><span class="p">()</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">downscale_local_mean</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">factors</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">downsample</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span><span class="p">))</span>

            <span class="c1"># In debug mode we highlight each tile edge to see where it was</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">data</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">x1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">H_pos</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">H_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">V_pos</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">V_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">z1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">D_pos</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">z2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">D_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="tileMerger.merge_segmentation"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileMerger.merge_segmentation">[docs]</a>    <span class="k">def</span> <span class="nf">merge_segmentation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reconstruction_mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">tree_mode</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform merging with a maximum algorithm for overlapping areas.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode: string</span>
<span class="sd">            APR reconstruction type among (&#39;constant&#39;, &#39;smooth&#39;, &#39;level&#39;)</span>
<span class="sd">        debug: bool</span>
<span class="sd">            add white border on the edge of each tile to see where it was overlapping.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_segmentation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_merged_segmentation</span><span class="p">()</span>

        <span class="n">H_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_H&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">H_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">H_pos</span> <span class="o">-</span> <span class="n">H_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">downsample</span>
        <span class="n">V_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_V&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">V_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">V_pos</span> <span class="o">-</span> <span class="n">V_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">downsample</span>
        <span class="n">D_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_D&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">D_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">D_pos</span> <span class="o">-</span> <span class="n">D_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">downsample</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tile</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Merging&#39;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">progress_bar</span><span class="p">)):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;apr&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lazy</span><span class="p">:</span>
                    <span class="n">tile</span><span class="o">.</span><span class="n">lazy_load_segmentation</span><span class="p">(</span><span class="n">level_delta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">level_delta</span><span class="p">)</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_segmentation</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tile</span><span class="o">.</span><span class="n">load_segmentation</span><span class="p">()</span>
                    <span class="n">u</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">reconstruction</span><span class="o">.</span><span class="n">APRSlicer</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">parts_cc</span><span class="p">,</span> <span class="n">level_delta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">level_delta</span><span class="p">,</span>
                                                        <span class="n">mode</span><span class="o">=</span><span class="n">reconstruction_mode</span><span class="p">,</span> <span class="n">tree_mode</span><span class="o">=</span><span class="n">tree_mode</span><span class="p">)</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span>

            <span class="c1"># In debug mode we highlight each tile edge to see where it was</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">data</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">x1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">H_pos</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">H_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">V_pos</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">V_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">z1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">D_pos</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">z2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">D_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">merged_segmentation</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">merged_segmentation</span><span class="p">[</span><span class="n">z1</span><span class="p">:</span><span class="n">z2</span><span class="p">,</span> <span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="tileMerger.crop"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileMerger.crop">[docs]</a>    <span class="k">def</span> <span class="nf">crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ylim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zlim</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a black mask around the brain (rather than really cropping which makes the overlays complicated in</span>
<span class="sd">        a later stage).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        background: int</span>
<span class="sd">            constant value to replace the cropped area with.</span>
<span class="sd">        xlim: array_like</span>
<span class="sd">            x limits for cropping</span>
<span class="sd">        ylim: array_like</span>
<span class="sd">            y limits for cropping</span>
<span class="sd">        zlim: array_like</span>
<span class="sd">            z limits for cropping</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: please merge data before cropping.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">xlim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="n">xlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">background</span>
            <span class="k">if</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">background</span>
        <span class="k">if</span> <span class="n">ylim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ylim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">background</span>
            <span class="k">if</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span><span class="p">[:,</span> <span class="n">ylim</span><span class="p">[</span><span class="mi">1</span><span class="p">]:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">background</span>
        <span class="k">if</span> <span class="n">zlim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span><span class="p">[:</span><span class="n">zlim</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">background</span>
            <span class="k">if</span> <span class="n">zlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span><span class="p">[</span><span class="n">zlim</span><span class="p">[</span><span class="mi">1</span><span class="p">]:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">background</span></div>

<div class="viewcode-block" id="tileMerger.equalize_hist"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileMerger.equalize_hist">[docs]</a>    <span class="k">def</span> <span class="nf">equalize_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;opencv&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform histogram equalization to improve the contrast on merged data.</span>
<span class="sd">        Both OpenCV (only 2D) and Skimage (3D but 10 times slower) are available.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method: string</span>
<span class="sd">            method for performing histogram equalization among &#39;skimage&#39; and &#39;opencv&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: please merge data before equalizing histogram.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;opencv&#39;</span><span class="p">:</span>
            <span class="n">clahe</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">createCLAHE</span><span class="p">(</span><span class="n">tileGridSize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">clahe</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;skimage&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span> <span class="o">=</span> <span class="n">equalize_adapthist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error: unknown method for adaptive histogram normalization.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="tileMerger.set_downsample"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileMerger.set_downsample">[docs]</a>    <span class="k">def</span> <span class="nf">set_downsample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">downsample</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the downsampling value for the merging reconstruction.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        downsample: int</span>
<span class="sd">            downsample factor</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: find a more rigorous way of enforcing this. (Probably requires that the APR is loaded).</span>
        <span class="k">if</span> <span class="n">downsample</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error: downsample value should be compatible with APR levels.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span> <span class="o">=</span> <span class="n">downsample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">level_delta</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">downsample</span><span class="p">))</span></div>

<div class="viewcode-block" id="tileMerger._initialize_merged_array"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileMerger._initialize_merged_array">[docs]</a>    <span class="k">def</span> <span class="nf">_initialize_merged_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the merged array in accordance with the asked downsampling.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_nx</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ny</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_ny</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nz</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_nz</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">merged_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="tileMerger._initialize_merged_segmentation"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileMerger._initialize_merged_segmentation">[docs]</a>    <span class="k">def</span> <span class="nf">_initialize_merged_segmentation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the merged array in accordance with the asked downsampling.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_nx</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ny</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_ny</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nz</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_nz</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">merged_segmentation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="tileMerger._get_nx"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileMerger._get_nx">[docs]</a>    <span class="k">def</span> <span class="nf">_get_nx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the merged array size for x dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        _: int</span>
<span class="sd">            x size for merged array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_H&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">x_pos</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">x_pos</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span></div>

<div class="viewcode-block" id="tileMerger._get_ny"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileMerger._get_ny">[docs]</a>    <span class="k">def</span> <span class="nf">_get_ny</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the merged array size for y dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        _: int</span>
<span class="sd">            y size for merged array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_V&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">y_pos</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">y_pos</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span></div>

<div class="viewcode-block" id="tileMerger._get_nz"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileMerger._get_nz">[docs]</a>    <span class="k">def</span> <span class="nf">_get_nz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the merged array size for y dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        _: int</span>
<span class="sd">            y size for merged array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">z_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_D&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">z_pos</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">z_pos</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_planes</span></div>

<div class="viewcode-block" id="tileMerger._get_n_planes"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileMerger._get_n_planes">[docs]</a>    <span class="k">def</span> <span class="nf">_get_n_planes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a tile and check the number of planes per tile.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        _: int</span>
<span class="sd">            Number of planes per tile;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;apr&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lazy</span><span class="p">:</span>
                <span class="n">tile</span><span class="o">.</span><span class="n">lazy_load_tile</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tile</span><span class="o">.</span><span class="n">load_tile</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">tile</span><span class="o">.</span><span class="n">apr</span><span class="o">.</span><span class="n">shape</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tile</span><span class="o">.</span><span class="n">load_tile</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">tile</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="tileMerger._find_if_lazy"><a class="viewcode-back" href="../../paprica.stitcher.html#paprica.stitcher.tileMerger._find_if_lazy">[docs]</a>    <span class="k">def</span> <span class="nf">_find_if_lazy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to test if all tile can be lazy loaded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        _: bool</span>
<span class="sd">            True if the tile can be lazy loaded, false if not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">:</span>
                <span class="n">tile</span><span class="o">.</span><span class="n">lazy_load_tile</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Wyss Center for Bio and Neuro Engineering.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>