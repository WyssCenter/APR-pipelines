<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>paprica.runner &mdash; paprica 0.0.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> paprica
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">How to install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../documentation.html">Generating documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../testing.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API reference:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../paprica.atlaser.html">paprica.atlaser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../paprica.batcher.html">paprica.batcher</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../paprica.converter.html">paprica.converter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../paprica.loader.html">paprica.loader</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../paprica.parser.html">paprica.parser</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../paprica.segmenter.html">paprica.segmenter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../paprica.stitcher.html">paprica.stitcher</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../paprica.viewer.html">paprica.viewer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../paprica.runner.html">paprica.runner</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">paprica</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">paprica.runner</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for paprica.runner</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Submodule containing classes and functions relative to the running pipeline.</span>

<span class="sd">By using this code you agree to the terms of the software license agreement.</span>

<span class="sd">© Copyright 2020 Wyss Center for Bio and Neuro Engineering – All rights reserved</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">pyapr</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.csgraph</span> <span class="kn">import</span> <span class="n">minimum_spanning_tree</span><span class="p">,</span> <span class="n">depth_first_order</span>
<span class="kn">from</span> <span class="nn">skimage.exposure</span> <span class="kn">import</span> <span class="n">rescale_intensity</span>
<span class="kn">from</span> <span class="nn">skimage.filters</span> <span class="kn">import</span> <span class="n">gaussian</span>
<span class="kn">from</span> <span class="nn">skimage.color</span> <span class="kn">import</span> <span class="n">hsv2rgb</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">import</span> <span class="nn">paprica</span>
<span class="kn">from</span> <span class="nn">paprica.stitcher</span> <span class="kn">import</span> <span class="n">_get_max_proj_apr</span><span class="p">,</span> <span class="n">_get_proj_shifts</span><span class="p">,</span> <span class="n">_get_masked_proj_shifts</span>


<div class="viewcode-block" id="clearscopeRunningPipeline"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline">[docs]</a><span class="k">class</span> <span class="nc">clearscopeRunningPipeline</span><span class="p">():</span>

<div class="viewcode-block" id="clearscopeRunningPipeline.__init__"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">n_channels</span><span class="p">,</span> <span class="n">output_path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for the clearscopeRunningPipeline.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path: str</span>
<span class="sd">            Path of the acquisition. It has to be the acquisition folder (root of /0001/ folder).</span>
<span class="sd">        n_channels: int</span>
<span class="sd">            Number of channels that will be acquired. This will be parsed/guessed in the future.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># runningPipeline attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;0001&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">output_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_path</span> <span class="o">=</span> <span class="n">output_path</span>
        <span class="c1"># self.folder_settings = self.path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">folder_settings</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name_acq</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="c1"># self.folder_settings, self.name_acq = os.path.split(path)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span> <span class="o">=</span> <span class="mi">2048</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_channels</span> <span class="o">=</span> <span class="n">n_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_processed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="s1">&#39;clearscope&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_tile</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_channel</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Parsing acquisition parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acq_param</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nrow</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_planes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlap_v</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlap_h</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_acquisition_settings</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrow</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">projs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1"># # Viewer initialisation</span>
        <span class="c1"># if viewer:</span>
        <span class="c1">#     self.viewer = napari.Viewer()</span>
        <span class="c1">#     napari.run()</span>
        <span class="c1"># else:</span>
        <span class="c1">#     self.viewer = None</span>

        <span class="c1"># Converter attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">converter</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lazy_loading</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compression</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bg</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quantization_factor</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">folder_apr</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Stitcher attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paths_apr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stitcher</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_vertex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">folder_max_projs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">segment</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segmenter</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reg_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="o">*</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reg_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="o">*</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reg_z</span> <span class="o">=</span> <span class="mi">20</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">z_begin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_end</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_from</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_to</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relia_H</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relia_V</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relia_D</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dH</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dV</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dD</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Attributes below are set when the corresponding method are called.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_rel</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_abs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctree_from_H</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctree_from_V</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctree_from_D</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctree_to_H</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctree_to_V</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctree_to_D</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_tree_H</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_tree_V</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_tree_D</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_relia_H</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_relia_V</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_relia_D</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">database</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline.run"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Start the running pipeline. It is basically a loop waiting for each tile to be saved at the specified path.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_processed</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_channels</span><span class="p">:</span>

            <span class="n">is_available</span><span class="p">,</span> <span class="n">tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_new_tile_available</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">is_available</span><span class="p">:</span>

                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">New tile available: </span><span class="si">{}</span><span class="se">\n</span><span class="s1">row: </span><span class="si">{}</span><span class="se">\n</span><span class="s1">col </span><span class="si">{}</span><span class="se">\n</span><span class="s1">channel </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
                                                                                      <span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span>
                                                                                      <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">,</span>
                                                                                      <span class="n">tile</span><span class="o">.</span><span class="n">channel</span><span class="p">))</span>

                <span class="c1"># We check if the APR file is already available (e.g. something crashed and we restart the pipeline)</span>
                <span class="n">apr</span><span class="p">,</span> <span class="n">parts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_for_apr_file</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">apr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tile</span><span class="o">.</span><span class="n">load_tile</span><span class="p">()</span>

                    <span class="c1"># Convert tile</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">converter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_convert_to_apr</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_check_conversion</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tile</span><span class="o">.</span><span class="n">apr</span> <span class="o">=</span> <span class="n">apr</span>
                    <span class="n">tile</span><span class="o">.</span><span class="n">parts</span> <span class="o">=</span> <span class="n">parts</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stitcher</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_pre_stitch</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_update_next_tile</span><span class="p">()</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">tile_processed</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stitcher</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_sparse_graphs</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_optimize_sparse_graphs</span><span class="p">()</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_produce_registration_map</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_database</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_print_info</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_apr</span><span class="p">,</span>
                                              <span class="s1">&#39;ch</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stitched_channel</span><span class="p">),</span>
                                              <span class="s1">&#39;registration_results.csv&#39;</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span> <span class="o">=</span> <span class="n">paprica</span><span class="o">.</span><span class="n">tileParser</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_apr</span><span class="p">,</span> <span class="s1">&#39;ch</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stitched_channel</span><span class="p">)))</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline.activate_conversion"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline.activate_conversion">[docs]</a>    <span class="k">def</span> <span class="nf">activate_conversion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                             <span class="n">Ip_th</span><span class="o">=</span><span class="mi">108</span><span class="p">,</span>
                             <span class="n">rel_error</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
                             <span class="n">gradient_smoothing</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                             <span class="n">dx</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                             <span class="n">dy</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                             <span class="n">dz</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                             <span class="n">lazy_loading</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Activate conversion for the running pipeline.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Ip_th: int</span>
<span class="sd">            Intensity threshold</span>
<span class="sd">        rel_error: float in [0, 1[</span>
<span class="sd">            relative error bound</span>
<span class="sd">        gradient_smoothing: (float)</span>
<span class="sd">            B-Spline smoothing parameter (typically between 0 (no smoothing) and 10 (LOTS of smoothing)</span>
<span class="sd">        dx: float</span>
<span class="sd">            PSF size in x, used to compute the gradient</span>
<span class="sd">        dy: float</span>
<span class="sd">            PSF size in y, used to compute the gradient</span>
<span class="sd">        dz: float</span>
<span class="sd">            PSF size in z, used to compute the gradient</span>
<span class="sd">        lazy_loading: bool</span>
<span class="sd">            if lazy_loading is true then the converter save mean tree particle which are necessary for lazy loading of</span>
<span class="sd">            the APR. It will require about 1/7 more storage.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Store parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lazy_loading</span> <span class="o">=</span> <span class="n">lazy_loading</span>

        <span class="c1"># Safely create folder to save apr data</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_channels</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">folder_apr</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_path</span><span class="p">,</span> <span class="s1">&#39;APR&#39;</span><span class="p">)</span>
            <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_apr</span><span class="p">,</span> <span class="s1">&#39;ch</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Set parameters</span>
        <span class="n">par</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">APRParameters</span><span class="p">()</span>
        <span class="n">par</span><span class="o">.</span><span class="n">Ip_th</span> <span class="o">=</span> <span class="n">Ip_th</span>
        <span class="n">par</span><span class="o">.</span><span class="n">rel_error</span> <span class="o">=</span> <span class="n">rel_error</span>
        <span class="n">par</span><span class="o">.</span><span class="n">dx</span> <span class="o">=</span> <span class="n">dx</span>
        <span class="n">par</span><span class="o">.</span><span class="n">dy</span> <span class="o">=</span> <span class="n">dy</span>
        <span class="n">par</span><span class="o">.</span><span class="n">dz</span> <span class="o">=</span> <span class="n">dz</span>
        <span class="n">par</span><span class="o">.</span><span class="n">gradient_smoothing</span> <span class="o">=</span> <span class="n">gradient_smoothing</span>
        <span class="n">par</span><span class="o">.</span><span class="n">auto_parameters</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Create converter object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">converter</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">FloatConverter</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">set_parameters</span><span class="p">(</span><span class="n">par</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline.set_compression"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline.set_compression">[docs]</a>    <span class="k">def</span> <span class="nf">set_compression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantization_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bg</span><span class="o">=</span><span class="mi">108</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Activate B3D compression for saving tiles.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        quantization_factor: int</span>
<span class="sd">            quantization factor: the higher, the more compressed (refer to B3D paper for more detail).</span>
<span class="sd">        bg: int</span>
<span class="sd">            background value: any value below this threshold will be set to the background value. This helps</span>
<span class="sd">            save up space by having the same value for the background (refer to B3D paper for more details).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">compression</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bg</span> <span class="o">=</span> <span class="n">bg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quantization_factor</span> <span class="o">=</span> <span class="n">quantization_factor</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline.deactivate_compression"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline.deactivate_compression">[docs]</a>    <span class="k">def</span> <span class="nf">deactivate_compression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deactivate B3D compression when saving particles.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">compression</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bg</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quantization_factor</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline.activate_stitching"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline.activate_stitching">[docs]</a>    <span class="k">def</span> <span class="nf">activate_stitching</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Activate stitching the data for the running pipeline.</span>

<span class="sd">        Stitching the data consists in:</span>

<span class="sd">        1) Computing the maximum intensity projections for each side that will have a neighboring tile once a tile is</span>
<span class="sd">        completely acquired</span>
<span class="sd">        2) Once a neighboring tile is available and the maximum intensity projections have been computed for this tile,</span>
<span class="sd">        estimate the pairwise registration parameters, saving the results in a graph for each dimension, along with the</span>
<span class="sd">        reliability of the estimation.</span>
<span class="sd">        3) Globaly optimize at the end to find the optimal tile placement.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        channel: int</span>
<span class="sd">            Number of the channel to perform the stitching on.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stitcher</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stitched_channel</span> <span class="o">=</span> <span class="n">channel</span>

        <span class="c1"># Safely create folder to save max projs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">folder_max_projs</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_path</span><span class="p">,</span> <span class="s1">&#39;max_projs&#39;</span><span class="p">)</span>
        <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_max_projs</span><span class="p">,</span> <span class="s1">&#39;ch</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">channel</span><span class="p">)))</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline.set_regularization"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline.set_regularization">[docs]</a>    <span class="k">def</span> <span class="nf">set_regularization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reg_x</span><span class="p">,</span> <span class="n">reg_y</span><span class="p">,</span> <span class="n">reg_z</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the regularization for the stitching to prevent aberrant displacements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reg_x: int</span>
<span class="sd">            if the horizontal displacement computed in the pairwise registration for any tile is greater than</span>
<span class="sd">            reg_x (in pixel unit) then the expected displacement (from motor position) is taken.</span>
<span class="sd">        reg_y: int</span>
<span class="sd">            if the horizontal displacement computed in the pairwise registration for any tile is greater than</span>
<span class="sd">            reg_z (in pixel unit) then the expected displacement (from motor position) is taken.</span>
<span class="sd">        reg_z: int</span>
<span class="sd">            if the horizontal displacement computed in the pairwise registration for any tile is greater than</span>
<span class="sd">            reg_z (in pixel unit) then the expected displacement (from motor position) is taken.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reg_x</span> <span class="o">=</span> <span class="n">reg_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reg_y</span> <span class="o">=</span> <span class="n">reg_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reg_z</span> <span class="o">=</span> <span class="n">reg_z</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline.set_z_range"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline.set_z_range">[docs]</a>    <span class="k">def</span> <span class="nf">set_z_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z_begin</span><span class="p">,</span> <span class="n">z_end</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a range of depth fo computing the stitching.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        z_begin: int</span>
<span class="sd">            first depth to be included in the max-proj</span>
<span class="sd">        z_end: int</span>
<span class="sd">            last depth to be included in the max-proj</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">z_begin</span> <span class="o">=</span> <span class="n">z_begin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_end</span> <span class="o">=</span> <span class="n">z_end</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline.set_overlap_margin"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline.set_overlap_margin">[docs]</a>    <span class="k">def</span> <span class="nf">set_overlap_margin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">margin</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modify the overlaping area size. If the overlaping area is smaller than the true one, the stitching can&#39;t</span>
<span class="sd">        be performed properly. If the overlaping area area is more than twice the size of the true one it will also</span>
<span class="sd">        fail (due to the circular FFT in the phase cross correlation).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        margin: float</span>
<span class="sd">            safety margin in % to take the overlaping area.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">margin</span> <span class="o">&gt;</span> <span class="mi">45</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error: overlap margin is too big and will make the stitching fail.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">margin</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error: overlap margin is too small and may make the stitching fail.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">overlap_h</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">margin</span><span class="o">/</span><span class="mi">100</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlap_v</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">margin</span><span class="o">/</span><span class="mi">100</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline.reconstruct_slice"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline.reconstruct_slice">[docs]</a>    <span class="k">def</span> <span class="nf">reconstruct_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_proj</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">downsample</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reconstruct whole sample 2D section at the given location and in a given dimension. This function can also</span>
<span class="sd">        reconstruct a maximum intensity projection if `n_proj&gt;0`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loc: int (default: middle of the sample)</span>
<span class="sd">            Position of the plane where the reconstruction should be done. The location varies depending on the</span>
<span class="sd">            downsample parameter and should be adapted.</span>
<span class="sd">        n_proj: int (default: 0)</span>
<span class="sd">            Number of planes to perform the maximum intensity projection.</span>
<span class="sd">        dim: int (default: 0)</span>
<span class="sd">            Dimension of the reconstruction, e.g. 0 will be [y, x] plane (orthogonal to z).</span>
<span class="sd">        downsample: int (default: 1)</span>
<span class="sd">            Downsample factor for the reconstruction. Must be in [1, 2, 4, 8, 16, 32].</span>
<span class="sd">        color: bool (default: False)</span>
<span class="sd">            Option to reconstruct with checkerboard color pattern. Useful to identify doubling artifacts.</span>
<span class="sd">        debug: bool (default: False)</span>
<span class="sd">            Option to add a white square for each tile, making it easy to see overlapping areas.</span>
<span class="sd">        plot: bool (default: True)</span>
<span class="sd">            Define if the function plots the results with Matplotlib or just returns an array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        _: ndarray</span>
<span class="sd">            Array containing the reconstructed data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reconstruct_z_slice</span><span class="p">(</span><span class="n">z</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">n_proj</span><span class="o">=</span><span class="n">n_proj</span><span class="p">,</span> <span class="n">downsample</span><span class="o">=</span><span class="n">downsample</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span>
                                             <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reconstruct_y_slice</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">n_proj</span><span class="o">=</span><span class="n">n_proj</span><span class="p">,</span> <span class="n">downsample</span><span class="o">=</span><span class="n">downsample</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span>
                                             <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reconstruct_x_slice</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span> <span class="n">n_proj</span><span class="o">=</span><span class="n">n_proj</span><span class="p">,</span> <span class="n">downsample</span><span class="o">=</span><span class="n">downsample</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span>
                                             <span class="n">plot</span><span class="o">=</span><span class="n">plot</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline.reconstruct_z_color"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline.reconstruct_z_color">[docs]</a>    <span class="k">def</span> <span class="nf">reconstruct_z_color</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_proj</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">downsample</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reconstruct and merge the sample at a given depth z.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        z: int</span>
<span class="sd">            reconstruction depth</span>
<span class="sd">        downsample: int</span>
<span class="sd">            downsample for reconstruction (must be a power of 2)</span>
<span class="sd">        debug: bool</span>
<span class="sd">            if true the border of each tile will be highlighted</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        merged_data: ndarray</span>
<span class="sd">            Merged frame at depth z.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">level_delta</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">downsample</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">downsample</span><span class="p">)))</span>

        <span class="n">tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">tile</span><span class="o">.</span><span class="n">lazy_load_tile</span><span class="p">(</span><span class="n">level_delta</span><span class="o">=</span><span class="n">level_delta</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error: z is too large (</span><span class="si">{}</span><span class="s1">), maximum depth at this downsample is </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">z</span><span class="p">,</span>
                                                                                                          <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span>
                                                                                                              <span class="mi">0</span><span class="p">]))</span>

        <span class="n">frame_size</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">x_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_H&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">x_pos</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">x_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="n">downsample</span> <span class="o">+</span> <span class="n">frame_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">y_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_V&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">y_pos</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">y_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="n">downsample</span> <span class="o">+</span> <span class="n">frame_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.7</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">)</span>

        <span class="n">H_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_pos</span> <span class="o">-</span> <span class="n">x_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="n">downsample</span>
        <span class="n">V_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_pos</span> <span class="o">-</span> <span class="n">y_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="n">downsample</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tile</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Merging&#39;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">progress_bar</span><span class="p">)):</span>
            <span class="n">tile</span><span class="o">.</span><span class="n">lazy_load_tile</span><span class="p">(</span><span class="n">level_delta</span><span class="o">=</span><span class="n">level_delta</span><span class="p">)</span>
            <span class="n">zf</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">z</span> <span class="o">+</span> <span class="n">n_proj</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="p">[</span><span class="n">z</span><span class="p">:</span><span class="n">zf</span><span class="p">]</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># In debug mode we highlight each tile edge to see where it was</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">v</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">v</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">x1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">H_pos</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">H_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">V_pos</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">V_pos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="n">V</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">],</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">H</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">],</span> <span class="n">h</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">rescale_intensity</span><span class="p">(</span><span class="n">gaussian</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span> <span class="n">out_range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.66</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">V</span> <span class="o">+</span> <span class="mi">200</span><span class="p">)</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">V</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">100</span><span class="p">)],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">99.9</span><span class="p">))</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">rescale_intensity</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">in_range</span><span class="o">=</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">),</span> <span class="n">out_range</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">S</span> <span class="o">*</span> <span class="n">V</span>
        <span class="n">rgb</span> <span class="o">=</span> <span class="n">hsv2rgb</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">H</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">V</span><span class="p">)))</span>
        <span class="n">rescale_intensity</span><span class="p">(</span><span class="n">rgb</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">rgb</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rgb</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline._reconstruct_z_slice"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline._reconstruct_z_slice">[docs]</a>    <span class="k">def</span> <span class="nf">_reconstruct_z_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_proj</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">downsample</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reconstruct and merge the sample at a given depth z.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        z: int</span>
<span class="sd">            reconstruction depth (vary with downsample)</span>
<span class="sd">        n_proj: int (default: 0)</span>
<span class="sd">            Number of planes to perform the maximum intensity projection.</span>
<span class="sd">        dim: int (default: 0)</span>
<span class="sd">            Dimension of the reconstruction, e.g. 0 will be [y, x] plane (orthogonal to z).</span>
<span class="sd">        downsample: int (default: 1)</span>
<span class="sd">            Downsample factor for the reconstruction. Must be in [1, 2, 4, 8, 16, 32].</span>
<span class="sd">        color: bool (default: False)</span>
<span class="sd">            Option to reconstruct with checkerboard color pattern. Useful to identify doubling artifacts.</span>
<span class="sd">        debug: bool (default: False)</span>
<span class="sd">            Option to add a white square for each tile, making it easy to see overlapping areas.</span>
<span class="sd">        plot: bool (default: True)</span>
<span class="sd">            Define if the function plots the results with Matplotlib or just returns an array.</span>
<span class="sd">        seg: bool (default: False)</span>
<span class="sd">            Option to also reconstruct the segmentation. Only works with `dim=0`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        merged_data: ndarray</span>
<span class="sd">            Merged frame at depth z.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">level_delta</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">downsample</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">downsample</span><span class="p">)))</span>

        <span class="n">tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">tile</span><span class="o">.</span><span class="n">lazy_load_tile</span><span class="p">(</span><span class="n">level_delta</span><span class="o">=</span><span class="n">level_delta</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error: z is too large (</span><span class="si">{}</span><span class="s1">), maximum depth at this downsample is </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">z</span><span class="p">,</span>
                                                                                                          <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span>
                                                                                                              <span class="mi">0</span><span class="p">]))</span>

        <span class="n">frame_size</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">x_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_H&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">x_pos</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">x_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="n">downsample</span> <span class="o">+</span> <span class="n">frame_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">y_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="s1">&#39;ABS_V&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">y_pos</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">y_pos</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">/</span> <span class="n">downsample</span> <span class="o">+</span> <span class="n">frame_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">color</span><span class="p">:</span>
            <span class="n">merged_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">)</span>
            <span class="n">merged_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">merged_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tile</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Merging&#39;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">progress_bar</span><span class="p">)):</span>

            <span class="n">H_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;row==</span><span class="si">{}</span><span class="s1"> &amp; col==</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">))[</span><span class="s1">&#39;ABS_H&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">downsample</span>
            <span class="n">V_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">&#39;row==</span><span class="si">{}</span><span class="s1"> &amp; col==</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">))[</span><span class="s1">&#39;ABS_V&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">downsample</span>

            <span class="n">tile</span><span class="o">.</span><span class="n">lazy_load_tile</span><span class="p">(</span><span class="n">level_delta</span><span class="o">=</span><span class="n">level_delta</span><span class="p">)</span>
            <span class="n">zf</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">z</span> <span class="o">+</span> <span class="n">n_proj</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">zf</span> <span class="o">&gt;</span> <span class="n">z</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="p">[</span><span class="n">z</span><span class="p">:</span><span class="n">zf</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">lazy_data</span><span class="p">[</span><span class="n">z</span><span class="p">]</span>

            <span class="c1"># In debug mode we highlight each tile edge to see where it was</span>
            <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                <span class="n">xv</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span><span class="o">/</span><span class="n">downsample</span><span class="p">)</span>
                <span class="n">xh</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span><span class="o">/</span><span class="n">downsample</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="n">xv</span><span class="p">,</span> <span class="n">xh</span><span class="p">:</span><span class="o">-</span><span class="n">xh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="n">xv</span><span class="p">,</span> <span class="n">xh</span><span class="p">:</span><span class="o">-</span><span class="n">xh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">data</span><span class="p">[</span><span class="n">xv</span><span class="p">:</span><span class="o">-</span><span class="n">xv</span><span class="p">,</span> <span class="n">xh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span>
                <span class="n">data</span><span class="p">[</span><span class="n">xv</span><span class="p">:</span><span class="o">-</span><span class="n">xv</span><span class="p">,</span> <span class="o">-</span><span class="n">xh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">16</span><span class="o">-</span><span class="mi">1</span>


            <span class="n">x1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">H_pos</span><span class="p">)</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">H_pos</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">V_pos</span><span class="p">)</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">V_pos</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">color</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">merged_data</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">merged_data</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">merged_data</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">merged_data</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">merged_data</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">merged_data</span><span class="p">[</span><span class="n">y1</span><span class="p">:</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">],</span> <span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">color</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_process_RGB_for_display</span><span class="p">(</span><span class="n">merged_data</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">merged_data</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">merged_data</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline._check_for_apr_file"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline._check_for_apr_file">[docs]</a>    <span class="k">def</span> <span class="nf">_check_for_apr_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if a given APR file already exists at a given location.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tile: pipapr.loader.tileLoader</span>
<span class="sd">            tileLoader object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        apr, parts: pypapr.APR, pyapr.ParticleData</span>
<span class="sd">            tuple containing APR and particles if found or (None, None) if not found.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">apr_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_apr</span><span class="p">,</span> <span class="s1">&#39;ch</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">channel</span><span class="p">),</span>
                                                    <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">.apr&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">apr_path</span><span class="p">):</span>
            <span class="n">apr</span><span class="p">,</span> <span class="n">parts</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">apr_path</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Tile </span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">.apr already exists!&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">apr</span><span class="p">,</span> <span class="n">parts</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline._parse_acquisition_settings"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline._parse_acquisition_settings">[docs]</a>    <span class="k">def</span> <span class="nf">_parse_acquisition_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function that parses the setting txt file created by cleascope software at the begining of the acquisition</span>
<span class="sd">        and automatically extract the required parameters for the running pipeline to work.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Waiting for AcquireSettings.txt file in </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span>
              <span class="nb">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_settings</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_AcquireSettings.txt&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name_acq</span><span class="p">))))</span>

        <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_settings</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_AcquireSettings.txt&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name_acq</span><span class="p">)))</span>
        <span class="c1"># files = glob(os.path.join(self.folder_settings, &#39;*.ini&#39;))</span>
        <span class="k">while</span> <span class="n">files</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_settings</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_AcquireSettings.txt&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name_acq</span><span class="p">)))</span>

        <span class="n">path</span> <span class="o">=</span> <span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;File found: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>


        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">acq_param</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="n">pattern_matched</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^(\w*) = (\S*)&#39;</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pattern_matched</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pattern_matched</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">isnumeric</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">acq_param</span><span class="p">[</span><span class="n">pattern_matched</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">pattern_matched</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">pattern_matched</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;True&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">acq_param</span><span class="p">[</span><span class="n">pattern_matched</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">pattern_matched</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;False&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">acq_param</span><span class="p">[</span><span class="n">pattern_matched</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">acq_param</span><span class="p">[</span><span class="n">pattern_matched</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pattern_matched</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nrow</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acq_param</span><span class="p">[</span><span class="s1">&#39;ScanGridY&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acq_param</span><span class="p">[</span><span class="s1">&#39;ScanGridX&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_planes</span> <span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acq_param</span><span class="p">[</span><span class="s1">&#39;StackDepths&#39;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acq_param</span><span class="p">[</span><span class="s1">&#39;VSThrowAwayYBottom&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">acq_param</span><span class="p">[</span><span class="s1">&#39;VSThrowAwayXRight&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">overlap_h</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span><span class="o">*</span><span class="mf">1.2</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlap_v</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span><span class="o">*</span><span class="mf">1.2</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Acquisition parameters:&#39;</span>
              <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">- number of row: </span><span class="si">{}</span><span class="s1">&#39;</span>
              <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">- number of col: </span><span class="si">{}</span><span class="s1">&#39;</span>
              <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">- number of planes: </span><span class="si">{}</span><span class="s1">&#39;</span>
              <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">- number of channels: </span><span class="si">{}</span><span class="s1">&#39;</span>
              <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">- horizontal overlap: </span><span class="si">{:0.2f}</span><span class="s1">%&#39;</span>
              <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">- vertical overlap: </span><span class="si">{:0.2f}</span><span class="s1">%&#39;</span>
              <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_planes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_channels</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="o">*</span><span class="mi">100</span><span class="p">))</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline._is_new_tile_available"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline._is_new_tile_available">[docs]</a>    <span class="k">def</span> <span class="nf">_is_new_tile_available</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if a new tile is available for processing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_available: bool</span>
<span class="sd">            True if a new tile is available, False otherwise</span>
<span class="sd">        tile: tileLoader</span>
<span class="sd">            tile object is available, None otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">expected_tile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;000000_</span><span class="si">{:06d}</span><span class="s1">___</span><span class="si">{}</span><span class="s1">c/&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_tile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_channel</span><span class="p">))</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">expected_tile</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">path</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Store current tile coordinate</span>
            <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">expected_tile</span><span class="p">,</span> <span class="s1">&#39;*.tif&#39;</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_planes</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tile</span><span class="p">(</span><span class="n">expected_tile</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">tile</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: multiple tiles were found.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline._get_row_col"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline._get_row_col">[docs]</a>    <span class="k">def</span> <span class="nf">_get_row_col</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get ClearScope tile row and col position given the tile path.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path: str</span>
<span class="sd">            ClearScope tile path</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        row, col: (int, int)</span>
<span class="sd">            row and col numbers</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pattern_search</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d</span><span class="si">{6}</span><span class="s1">_(\d</span><span class="si">{6}</span><span class="s1">)___\dc&#39;</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pattern_search</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pattern_search</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">)</span>

        <span class="n">col</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">row</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline._get_channel"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline._get_channel">[docs]</a>    <span class="k">def</span> <span class="nf">_get_channel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get channel from Clearscope tile path.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path: str</span>
<span class="sd">            Clearscope tile path</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        _: int</span>
<span class="sd">            Channel number</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pattern_search</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d</span><span class="si">{6}</span><span class="s1">_\d</span><span class="si">{6}</span><span class="s1">___(\d)c&#39;</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pattern_search</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">pattern_search</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline._update_next_tile"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline._update_next_tile">[docs]</a>    <span class="k">def</span> <span class="nf">_update_next_tile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update next tile coordinates given the expected pattern.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_channel</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_channels</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_tile</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_channel</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_channel</span> <span class="o">+=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline._get_tile"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline._get_tile">[docs]</a>    <span class="k">def</span> <span class="nf">_get_tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the tile at the given path.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path: string</span>
<span class="sd">            tile path</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tile: tileLoader</span>
<span class="sd">            tile object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_row_col</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="c1"># If row is even then neighbors are west and north</span>
        <span class="k">if</span> <span class="n">row</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># If first row then it is only west</span>
            <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">col</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">neighbors</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># Else it is also north</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">col</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">col</span><span class="p">]]</span>
                <span class="c1"># Except for first column it is only north</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[[</span><span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">col</span><span class="p">]]</span>
        <span class="c1"># If row is odd then neighbors are north and east</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[[</span><span class="n">row</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">,</span> <span class="n">col</span><span class="p">],</span> <span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="c1"># If last column then there is no east neighbor</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[[</span><span class="n">row</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">,</span> <span class="n">col</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">channel</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">stitched_channel</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">.apr&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paths_apr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_apr</span><span class="p">,</span> <span class="s1">&#39;ch</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">channel</span><span class="p">),</span> <span class="n">filename</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">paprica</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">tileLoader</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span>
                                         <span class="n">row</span><span class="o">=</span><span class="n">row</span><span class="p">,</span>
                                         <span class="n">col</span><span class="o">=</span><span class="n">col</span><span class="p">,</span>
                                         <span class="n">ftype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                                         <span class="n">neighbors</span><span class="o">=</span><span class="n">neighbors</span><span class="p">,</span>
                                         <span class="n">neighbors_tot</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">neighbors_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">frame_size</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span>
                                         <span class="n">folder_root</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>
                                         <span class="n">channel</span><span class="o">=</span><span class="n">channel</span><span class="p">)</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline._pre_stitch"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline._pre_stitch">[docs]</a>    <span class="k">def</span> <span class="nf">_pre_stitch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform pre-stitching, i.e. perform maximum intensity projection of the tile and register with available</span>
<span class="sd">        neighbors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tile: pipapr.loader.tileLoader</span>
<span class="sd">            tileLoader object containing the tile to perform the pre-stitiching on.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">channel</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">stitched_channel</span><span class="p">:</span>
            <span class="c1"># Max project current tile on the overlaping area.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_project_tile</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span>
            <span class="c1"># Compute pair-wise registration with existing neighbors</span>
            <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">neighbors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_register_tile</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline._register_tile"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline._register_tile">[docs]</a>    <span class="k">def</span> <span class="nf">_register_tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform pair-wise registration of a given tile with all its previously processed neighbors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tile: pipapr.loader.tileLoader</span>
<span class="sd">            tileLoader object containing the tile to perform the pre-stitiching on.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">proj1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">[</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">coords</span> <span class="ow">in</span> <span class="n">tile</span><span class="o">.</span><span class="n">neighbors</span><span class="p">:</span>
            <span class="n">proj2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">[</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

            <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">==</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span> <span class="o">&lt;</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="c1"># EAST</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">:</span>
                        <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="n">_get_masked_proj_shifts</span><span class="p">(</span><span class="n">proj1</span><span class="p">[</span><span class="s1">&#39;east&#39;</span><span class="p">],</span> <span class="n">proj2</span><span class="p">[</span><span class="s1">&#39;west&#39;</span><span class="p">],</span> <span class="n">threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="n">_get_proj_shifts</span><span class="p">(</span><span class="n">proj1</span><span class="p">[</span><span class="s1">&#39;east&#39;</span><span class="p">],</span> <span class="n">proj2</span><span class="p">[</span><span class="s1">&#39;west&#39;</span><span class="p">])</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_from</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">([</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">],</span>
                                                                 <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">)))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_to</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                                                               <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">)))</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># WEST</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">:</span>
                        <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="n">_get_masked_proj_shifts</span><span class="p">(</span><span class="n">proj2</span><span class="p">[</span><span class="s1">&#39;east&#39;</span><span class="p">],</span> <span class="n">proj1</span><span class="p">[</span><span class="s1">&#39;west&#39;</span><span class="p">],</span> <span class="n">threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="n">_get_proj_shifts</span><span class="p">(</span><span class="n">proj2</span><span class="p">[</span><span class="s1">&#39;east&#39;</span><span class="p">],</span> <span class="n">proj1</span><span class="p">[</span><span class="s1">&#39;west&#39;</span><span class="p">])</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_to</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">([</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">],</span>
                                                                 <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">)))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_from</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                                                               <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">)))</span>

            <span class="k">elif</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span> <span class="o">==</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="c1"># SOUTH</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">:</span>
                        <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="n">_get_masked_proj_shifts</span><span class="p">(</span><span class="n">proj1</span><span class="p">[</span><span class="s1">&#39;south&#39;</span><span class="p">],</span> <span class="n">proj2</span><span class="p">[</span><span class="s1">&#39;north&#39;</span><span class="p">],</span> <span class="n">threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="n">_get_proj_shifts</span><span class="p">(</span><span class="n">proj1</span><span class="p">[</span><span class="s1">&#39;south&#39;</span><span class="p">],</span> <span class="n">proj2</span><span class="p">[</span><span class="s1">&#39;north&#39;</span><span class="p">])</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_from</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">([</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">],</span>
                                                                     <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">)))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_to</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                                                                   <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">)))</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># NORTH</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">:</span>
                        <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="n">_get_masked_proj_shifts</span><span class="p">(</span><span class="n">proj2</span><span class="p">[</span><span class="s1">&#39;south&#39;</span><span class="p">],</span> <span class="n">proj1</span><span class="p">[</span><span class="s1">&#39;north&#39;</span><span class="p">],</span> <span class="n">threshold</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="n">_get_proj_shifts</span><span class="p">(</span><span class="n">proj2</span><span class="p">[</span><span class="s1">&#39;south&#39;</span><span class="p">],</span> <span class="n">proj1</span><span class="p">[</span><span class="s1">&#39;north&#39;</span><span class="p">])</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_to</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">([</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">],</span>
                                                                 <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">)))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_from</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">([</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                                                               <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">)))</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: couldn&#39;&#39;t determine registration to perform.&#39;</span><span class="p">)</span>



            <span class="c1"># Regularize in case of aberrant displacements</span>
            <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_regularize</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">rel</span><span class="p">)</span>

            <span class="c1"># H=x, V=y, D=z</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dH</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dV</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dD</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relia_H</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relia_V</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relia_D</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rel</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline._project_tile"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline._project_tile">[docs]</a>    <span class="k">def</span> <span class="nf">_project_tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform maximum intensity projection of the tile in the overlap area (+ predefined margin). For each tile</span>
<span class="sd">        a dictionnary ´tile´ is created and the ´[&#39;zy&#39;, &#39;zx&#39;, &#39;yx&#39;]´ projections are save as a list in the dictionnary</span>
<span class="sd">        where the key corresponds to the edge location ´[&#39;north&#39;, &#39;south&#39;, &#39;east&#39;, &#39;west&#39;]´.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tile: tileLoader</span>
<span class="sd">            tile object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">proj</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">:</span>
            <span class="c1"># check if projs allready exist:</span>
            <span class="n">compute</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;zy&#39;</span><span class="p">,</span> <span class="s1">&#39;zx&#39;</span><span class="p">,</span> <span class="s1">&#39;yx&#39;</span><span class="p">]):</span>
                <span class="n">path_to_check</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_max_projs</span><span class="p">,</span>
                                     <span class="s1">&#39;ch</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">channel</span><span class="p">),</span>
                                    <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_east_</span><span class="si">{}</span><span class="s1">.npy&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path_to_check</span><span class="p">):</span>
                    <span class="n">compute</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">compute</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">tile</span><span class="o">.</span><span class="n">is_loaded</span><span class="p">:</span>
                    <span class="n">tile</span><span class="o">.</span><span class="n">load_tile</span><span class="p">()</span>

                <span class="c1"># EAST 1</span>
                <span class="n">patch</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">ReconPatch</span><span class="p">()</span>
                <span class="n">patch</span><span class="o">.</span><span class="n">y_begin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_h</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_begin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;east&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_max_proj_apr</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">patch</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">patch_yx</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">ReconPatch</span><span class="p">()</span>
                    <span class="n">patch_yx</span><span class="o">.</span><span class="n">y_begin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_h</span>
                    <span class="n">patch_yx</span><span class="o">.</span><span class="n">z_begin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_begin</span>
                    <span class="n">patch_yx</span><span class="o">.</span><span class="n">z_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_end</span>
                    <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;east&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_max_proj_apr</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">patch</span><span class="o">=</span><span class="n">patch</span><span class="p">,</span> <span class="n">patch_yx</span><span class="o">=</span><span class="n">patch_yx</span><span class="p">,</span>
                                                          <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;zy&#39;</span><span class="p">,</span> <span class="s1">&#39;zx&#39;</span><span class="p">,</span> <span class="s1">&#39;yx&#39;</span><span class="p">]):</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_max_projs</span><span class="p">,</span>
                                         <span class="s1">&#39;ch</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">channel</span><span class="p">),</span>
                                        <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_east_</span><span class="si">{}</span><span class="s1">.npy&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">d</span><span class="p">)),</span> <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;east&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;east&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;zy&#39;</span><span class="p">,</span> <span class="s1">&#39;zx&#39;</span><span class="p">,</span> <span class="s1">&#39;yx&#39;</span><span class="p">]):</span>
                    <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;east&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_max_projs</span><span class="p">,</span>
                                                 <span class="s1">&#39;ch</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">channel</span><span class="p">),</span>
                                                 <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_east_</span><span class="si">{}</span><span class="s1">.npy&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">d</span><span class="p">))))</span>

        <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># check if projs allready exist:</span>
            <span class="n">compute</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;zy&#39;</span><span class="p">,</span> <span class="s1">&#39;zx&#39;</span><span class="p">,</span> <span class="s1">&#39;yx&#39;</span><span class="p">]):</span>
                <span class="n">path_to_check</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_max_projs</span><span class="p">,</span>
                                             <span class="s1">&#39;ch</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">channel</span><span class="p">),</span>
                                             <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_west_</span><span class="si">{}</span><span class="s1">.npy&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path_to_check</span><span class="p">):</span>
                    <span class="n">compute</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">compute</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">tile</span><span class="o">.</span><span class="n">is_loaded</span><span class="p">:</span>
                    <span class="n">tile</span><span class="o">.</span><span class="n">load_tile</span><span class="p">()</span>

                <span class="c1"># EAST 2</span>
                <span class="n">patch</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">ReconPatch</span><span class="p">()</span>
                <span class="n">patch</span><span class="o">.</span><span class="n">y_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_h</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_begin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;west&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_max_proj_apr</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">patch</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">patch_yx</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">ReconPatch</span><span class="p">()</span>
                    <span class="n">patch_yx</span><span class="o">.</span><span class="n">y_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_h</span>
                    <span class="n">patch_yx</span><span class="o">.</span><span class="n">z_begin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_begin</span>
                    <span class="n">patch_yx</span><span class="o">.</span><span class="n">z_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_end</span>
                    <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;west&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_max_proj_apr</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">patch</span><span class="o">=</span><span class="n">patch</span><span class="p">,</span> <span class="n">patch_yx</span><span class="o">=</span><span class="n">patch_yx</span><span class="p">,</span>
                                                          <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;zy&#39;</span><span class="p">,</span> <span class="s1">&#39;zx&#39;</span><span class="p">,</span> <span class="s1">&#39;yx&#39;</span><span class="p">]):</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_max_projs</span><span class="p">,</span>
                                         <span class="s1">&#39;ch</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">channel</span><span class="p">),</span>
                                        <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_west_</span><span class="si">{}</span><span class="s1">.npy&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">d</span><span class="p">)),</span> <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;west&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;west&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;zy&#39;</span><span class="p">,</span> <span class="s1">&#39;zx&#39;</span><span class="p">,</span> <span class="s1">&#39;yx&#39;</span><span class="p">]):</span>
                    <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;west&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_max_projs</span><span class="p">,</span>
                                                 <span class="s1">&#39;ch</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">channel</span><span class="p">),</span>
                                                 <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_west_</span><span class="si">{}</span><span class="s1">.npy&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">d</span><span class="p">))))</span>
        <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">:</span>
            <span class="c1"># check if projs allready exist:</span>
            <span class="n">compute</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;zy&#39;</span><span class="p">,</span> <span class="s1">&#39;zx&#39;</span><span class="p">,</span> <span class="s1">&#39;yx&#39;</span><span class="p">]):</span>
                <span class="n">path_to_check</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_max_projs</span><span class="p">,</span>
                                             <span class="s1">&#39;ch</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">channel</span><span class="p">),</span>
                                             <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_south_</span><span class="si">{}</span><span class="s1">.npy&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path_to_check</span><span class="p">):</span>
                    <span class="n">compute</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">compute</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">tile</span><span class="o">.</span><span class="n">is_loaded</span><span class="p">:</span>
                    <span class="n">tile</span><span class="o">.</span><span class="n">load_tile</span><span class="p">()</span>

                <span class="c1"># SOUTH 1</span>
                <span class="n">patch</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">ReconPatch</span><span class="p">()</span>
                <span class="n">patch</span><span class="o">.</span><span class="n">x_begin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_v</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_begin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;south&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_max_proj_apr</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">patch</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">patch_yx</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">ReconPatch</span><span class="p">()</span>
                    <span class="n">patch_yx</span><span class="o">.</span><span class="n">x_begin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_v</span>
                    <span class="n">patch_yx</span><span class="o">.</span><span class="n">z_begin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_begin</span>
                    <span class="n">patch_yx</span><span class="o">.</span><span class="n">z_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_end</span>
                    <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;south&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_max_proj_apr</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">patch</span><span class="o">=</span><span class="n">patch</span><span class="p">,</span> <span class="n">patch_yx</span><span class="o">=</span><span class="n">patch_yx</span><span class="p">,</span>
                                                           <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;zy&#39;</span><span class="p">,</span> <span class="s1">&#39;zx&#39;</span><span class="p">,</span> <span class="s1">&#39;yx&#39;</span><span class="p">]):</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_max_projs</span><span class="p">,</span>
                                         <span class="s1">&#39;ch</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">channel</span><span class="p">),</span>
                                        <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_south_</span><span class="si">{}</span><span class="s1">.npy&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">d</span><span class="p">)),</span> <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;south&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;south&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;zy&#39;</span><span class="p">,</span> <span class="s1">&#39;zx&#39;</span><span class="p">,</span> <span class="s1">&#39;yx&#39;</span><span class="p">]):</span>
                    <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;south&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_max_projs</span><span class="p">,</span>
                                                 <span class="s1">&#39;ch</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">channel</span><span class="p">),</span>
                                                 <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_south_</span><span class="si">{}</span><span class="s1">.npy&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">d</span><span class="p">))))</span>
        <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">row</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># check if projs allready exist:</span>
            <span class="n">compute</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;zy&#39;</span><span class="p">,</span> <span class="s1">&#39;zx&#39;</span><span class="p">,</span> <span class="s1">&#39;yx&#39;</span><span class="p">]):</span>
                <span class="n">path_to_check</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_max_projs</span><span class="p">,</span>
                                             <span class="s1">&#39;ch</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">channel</span><span class="p">),</span>
                                             <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_north_</span><span class="si">{}</span><span class="s1">.npy&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">path_to_check</span><span class="p">):</span>
                    <span class="n">compute</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">compute</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">tile</span><span class="o">.</span><span class="n">is_loaded</span><span class="p">:</span>
                    <span class="n">tile</span><span class="o">.</span><span class="n">load_tile</span><span class="p">()</span>

                <span class="c1"># SOUTH 2</span>
                <span class="n">patch</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">ReconPatch</span><span class="p">()</span>
                <span class="n">patch</span><span class="o">.</span><span class="n">x_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_v</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_begin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;north&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_max_proj_apr</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">patch</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">patch_yx</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">ReconPatch</span><span class="p">()</span>
                    <span class="n">patch_yx</span><span class="o">.</span><span class="n">x_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap_v</span>
                    <span class="n">patch_yx</span><span class="o">.</span><span class="n">z_begin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_begin</span>
                    <span class="n">patch_yx</span><span class="o">.</span><span class="n">z_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_end</span>
                    <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;north&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_max_proj_apr</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">parts</span><span class="p">,</span> <span class="n">patch</span><span class="o">=</span><span class="n">patch</span><span class="p">,</span> <span class="n">patch_yx</span><span class="o">=</span><span class="n">patch_yx</span><span class="p">,</span>
                                                           <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;zy&#39;</span><span class="p">,</span> <span class="s1">&#39;zx&#39;</span><span class="p">,</span> <span class="s1">&#39;yx&#39;</span><span class="p">]):</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_max_projs</span><span class="p">,</span>
                                         <span class="s1">&#39;ch</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">channel</span><span class="p">),</span>
                                        <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_north_</span><span class="si">{}</span><span class="s1">.npy&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">d</span><span class="p">)),</span> <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;north&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;north&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;zy&#39;</span><span class="p">,</span> <span class="s1">&#39;zx&#39;</span><span class="p">,</span> <span class="s1">&#39;yx&#39;</span><span class="p">]):</span>
                    <span class="n">proj</span><span class="p">[</span><span class="s1">&#39;north&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_max_projs</span><span class="p">,</span>
                                                 <span class="s1">&#39;ch</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">channel</span><span class="p">),</span>
                                                 <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_north_</span><span class="si">{}</span><span class="s1">.npy&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">d</span><span class="p">))))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">projs</span><span class="p">[</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">proj</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline._check_conversion"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline._check_conversion">[docs]</a>    <span class="k">def</span> <span class="nf">_check_conversion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks that conversion is ok, if not it should keep the original data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tile: tileLoader</span>
<span class="sd">            tile object to try if conversion worked as expected using facy metrics.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">conversion_ok</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># TODO: implement a way to check if conversion is ok.</span>

        <span class="k">if</span> <span class="n">conversion_ok</span><span class="p">:</span>
            <span class="n">tile</span><span class="o">.</span><span class="n">_erase_from_disk</span><span class="p">()</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline._convert_to_apr"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline._convert_to_apr">[docs]</a>    <span class="k">def</span> <span class="nf">_convert_to_apr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the given tile to APR.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tile: tileLoader</span>
<span class="sd">            tile object to be converted to APR.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">apr</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">APR</span><span class="p">()</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">ShortParticles</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">converter</span><span class="o">.</span><span class="n">get_apr</span><span class="p">(</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="n">parts</span><span class="o">.</span><span class="n">sample_image</span><span class="p">(</span><span class="n">apr</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compression</span><span class="p">:</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">set_compression_type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">set_quantization_factor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quantization_factor</span><span class="p">)</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">set_background</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bg</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lazy_loading</span><span class="p">:</span>
            <span class="n">tree_parts</span> <span class="o">=</span> <span class="n">pyapr</span><span class="o">.</span><span class="n">tree</span><span class="o">.</span><span class="n">fill_tree_mean</span><span class="p">(</span><span class="n">apr</span><span class="p">,</span> <span class="n">parts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tree_parts</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Save converted data</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">.apr&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">row</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>
        <span class="n">pyapr</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folder_apr</span><span class="p">,</span> <span class="s1">&#39;ch</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">channel</span><span class="p">),</span> <span class="n">filename</span><span class="p">),</span>
                       <span class="n">apr</span><span class="p">,</span> <span class="n">parts</span><span class="p">,</span> <span class="n">tree_parts</span><span class="o">=</span><span class="n">tree_parts</span><span class="p">)</span>

        <span class="n">tile</span><span class="o">.</span><span class="n">apr</span> <span class="o">=</span> <span class="n">apr</span>
        <span class="n">tile</span><span class="o">.</span><span class="n">parts</span> <span class="o">=</span> <span class="n">parts</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline._regularize"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline._regularize">[docs]</a>    <span class="k">def</span> <span class="nf">_regularize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove too large displacement and replace them with expected one with a large uncertainty.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reg: array_like</span>
<span class="sd">            list of registration (displacement) parameters</span>
<span class="sd">        rel: array_like</span>
<span class="sd">            list of reliability parameters corresponding to each displacement.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (reg, rel): (array_like, array_like)</span>
<span class="sd">            Updated lists after regularization.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_h</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span><span class="p">))</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg_x</span><span class="p">:</span>
            <span class="n">reg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_h</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span><span class="p">)</span>
            <span class="n">rel</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_v</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span><span class="p">))</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg_y</span><span class="p">:</span>
            <span class="n">reg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_v</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span><span class="p">)</span>
            <span class="n">rel</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">reg_z</span><span class="p">:</span>
            <span class="n">reg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">rel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="n">reg</span><span class="p">,</span> <span class="n">rel</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline._print_info"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline._print_info">[docs]</a>    <span class="k">def</span> <span class="nf">_print_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display stitching result information.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">registration_map_abs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">effective_overlap_h</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="o">-</span><span class="n">overlap</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="o">*</span><span class="mi">100</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Effective horizontal overlap: </span><span class="si">{:0.2f}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">effective_overlap_h</span><span class="p">))</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">registration_map_abs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">effective_overlap_v</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="o">-</span><span class="n">overlap</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="o">*</span><span class="mi">100</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Effective vertical overlap: </span><span class="si">{:0.2f}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">effective_overlap_v</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">effective_overlap_v</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="o">/</span><span class="mi">100</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span><span class="p">)</span><span class="o">&gt;</span><span class="mf">0.2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_v</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Expected vertical overlap is very different from the computed one, the registration &#39;</span>
                          <span class="s1">&#39;might be wrong.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">effective_overlap_h</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="o">/</span><span class="mi">100</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span><span class="p">)</span><span class="o">&gt;</span><span class="mf">0.2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">expected_overlap_h</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Expected horizontal overlap is very different from the computed one, the registration &#39;</span>
                          <span class="s1">&#39;might be wrong.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline._build_sparse_graphs"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline._build_sparse_graphs">[docs]</a>    <span class="k">def</span> <span class="nf">_build_sparse_graphs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the sparse graph from the reliability and (row, col). This method needs to be called after the</span>
<span class="sd">        pair-wise registration has been performed for all neighbors pair.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">csr_matrix_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_relia_H</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">relia_H</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cgraph_from</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_to</span><span class="p">)),</span>
                                        <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">csr_matrix_size</span><span class="p">,</span> <span class="n">csr_matrix_size</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_relia_V</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">relia_V</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cgraph_from</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_to</span><span class="p">)),</span>
                                        <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">csr_matrix_size</span><span class="p">,</span> <span class="n">csr_matrix_size</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph_relia_D</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">relia_D</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cgraph_from</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_to</span><span class="p">)),</span>
                                        <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">csr_matrix_size</span><span class="p">,</span> <span class="n">csr_matrix_size</span><span class="p">))</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline._optimize_sparse_graphs"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline._optimize_sparse_graphs">[docs]</a>    <span class="k">def</span> <span class="nf">_optimize_sparse_graphs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimize the sparse graph by computing the minimum spanning tree for each direction (H, D, V). This</span>
<span class="sd">        method needs to be called after the sparse graphs have been built.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_relia_H</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: sparse graph not build yet, please use build_sparse_graph() before trying to&#39;</span>
                            <span class="s1">&#39;perform the optimization.&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;graph_relia_H&#39;</span><span class="p">,</span> <span class="s1">&#39;graph_relia_V&#39;</span><span class="p">,</span> <span class="s1">&#39;graph_relia_D&#39;</span><span class="p">]:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
            <span class="c1"># Minimum spanning tree</span>
            <span class="n">min_tree</span> <span class="o">=</span> <span class="n">minimum_spanning_tree</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

            <span class="c1"># Get the &quot;true&quot; neighbors</span>
            <span class="n">min_tree</span> <span class="o">=</span> <span class="n">min_tree</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;min_tree_&#39;</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">min_tree</span><span class="p">)</span>
            <span class="n">ctree_from</span> <span class="o">=</span> <span class="n">min_tree</span><span class="o">.</span><span class="n">row</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ctree_from_&#39;</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ctree_from</span><span class="p">)</span>

            <span class="n">ctree_to</span> <span class="o">=</span> <span class="n">min_tree</span><span class="o">.</span><span class="n">col</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ctree_to_&#39;</span> <span class="o">+</span> <span class="n">g</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ctree_to</span><span class="p">)</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline._produce_registration_map"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline._produce_registration_map">[docs]</a>    <span class="k">def</span> <span class="nf">_produce_registration_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produce the registration map where reg_rel_map[d, row, col] (d = H,V,D) is the relative tile</span>
<span class="sd">        position in pixel from the expected one. This method needs to be called after the optimization has been done.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_tree_H</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: minimum spanning tree not computed yet, please use optimize_sparse_graph()&#39;</span>
                            <span class="s1">&#39;before trying to compute the registration map.&#39;</span><span class="p">)</span>

        <span class="c1"># Relative registration</span>
        <span class="c1"># Initialize relative registration map</span>
        <span class="n">reg_rel_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span> <span class="c1"># H, V, D</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">min_tree</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;min_tree_H&#39;</span><span class="p">,</span> <span class="s1">&#39;min_tree_V&#39;</span><span class="p">,</span> <span class="s1">&#39;min_tree_D&#39;</span><span class="p">]):</span>
            <span class="c1"># Fill it by following the tree and getting the corresponding registration parameters</span>
            <span class="n">node_array</span> <span class="o">=</span> <span class="n">depth_first_order</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_tree</span><span class="p">),</span> <span class="n">i_start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cgraph_from</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                           <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_predecessors</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">node_visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="n">tree</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_tree</span><span class="p">)</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">row</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">col</span>

            <span class="k">for</span> <span class="n">node_to</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node_array</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="c1"># The previous node in the MST is a visited node with an edge to the current node</span>
                <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="n">node_to</span><span class="p">:</span>
                        <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">node_to</span><span class="p">:</span>
                        <span class="n">neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="n">node_from</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">neighbors</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node_visited</span><span class="p">]</span>
                <span class="n">node_visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_to</span><span class="p">)</span>

                <span class="c1"># Get the previous neighbor local reg parameter</span>
                <span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">node_from</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
                <span class="n">d_neighbor</span> <span class="o">=</span> <span class="n">reg_rel_map</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">]</span>

                <span class="c1"># Get the current 2D tile position</span>
                <span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">node_to</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
                <span class="c1"># Get the associated ind position in the registration graph (as opposed to the reliability min_tree)</span>
                <span class="n">ind_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ind</span><span class="p">(</span><span class="n">node_from</span><span class="p">,</span> <span class="n">node_to</span><span class="p">)</span>
                <span class="c1"># Get the corresponding reg parameter</span>
                <span class="n">d</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span> <span class="o">+</span> <span class="n">min_tree</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="n">ind_graph</span><span class="p">]</span>
                <span class="c1"># Get the corresponding relia and print a warning if it was regularized:</span>
                <span class="n">relia</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;relia_&#39;</span> <span class="o">+</span> <span class="n">min_tree</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="n">ind_graph</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">relia</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Aberrant pair-wise registration remaining after global optimization between tile (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">) &#39;</span>
                          <span class="s1">&#39;and tile (</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">node_from</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">)),</span>
                                                    <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">node_to</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))))</span>
                <span class="c1"># Update the local reg parameter in the 2D matrix</span>
                <span class="k">if</span> <span class="n">node_to</span> <span class="o">&gt;</span> <span class="n">node_from</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">reg_rel_map</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_neighbor</span> <span class="o">+</span> <span class="n">d</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">reg_rel_map</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_neighbor</span> <span class="o">-</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_rel</span> <span class="o">=</span> <span class="n">reg_rel_map</span>

        <span class="n">reg_abs_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">reg_rel_map</span><span class="p">)</span>
        <span class="c1"># H</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reg_abs_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
            <span class="n">reg_abs_map</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg_rel_map</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_h</span><span class="p">)</span>
        <span class="c1"># V</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reg_abs_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">reg_abs_map</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">reg_rel_map</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">overlap_v</span><span class="p">)</span>
        <span class="c1"># D</span>
        <span class="n">reg_abs_map</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg_rel_map</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_abs</span> <span class="o">=</span> <span class="n">reg_abs_map</span>

        <span class="k">return</span> <span class="n">reg_rel_map</span><span class="p">,</span> <span class="n">reg_abs_map</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline._build_database"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline._build_database">[docs]</a>    <span class="k">def</span> <span class="nf">_build_database</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build the database for storing the registration parameters. This method needs to be called after</span>
<span class="sd">        the registration map has been produced.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_rel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: database can&#39;&#39;t be build if the registration map has not been computed.&#39;</span>
                            <span class="s1">&#39; Please use produce_registration_map() method first.&#39;</span><span class="p">)</span>

        <span class="n">database_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_tiles</span><span class="p">):</span>
            <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">database_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;path&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths_apr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                <span class="s1">&#39;row&#39;</span><span class="p">:</span> <span class="n">row</span><span class="p">,</span>
                                <span class="s1">&#39;col&#39;</span><span class="p">:</span> <span class="n">col</span><span class="p">,</span>
                                <span class="s1">&#39;dH&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_rel</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">],</span>
                                <span class="s1">&#39;dV&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_rel</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">],</span>
                                <span class="s1">&#39;dD&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_rel</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">],</span>
                                <span class="s1">&#39;ABS_H&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_abs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">],</span>
                                <span class="s1">&#39;ABS_V&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_abs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">],</span>
                                <span class="s1">&#39;ABS_D&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">registration_map_abs</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">database</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">database_dict</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>

        <span class="c1"># Finally set the origin so that tile on the edge have coordinate 0 (rather than negative):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;ABS_D&#39;</span><span class="p">,</span> <span class="s1">&#39;ABS_V&#39;</span><span class="p">,</span> <span class="s1">&#39;ABS_H&#39;</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">database</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span></div>
            
<div class="viewcode-block" id="clearscopeRunningPipeline._get_ind"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline._get_ind">[docs]</a>    <span class="k">def</span> <span class="nf">_get_ind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind_from</span><span class="p">,</span> <span class="n">ind_to</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the ind in the original graph which corresponds to (ind_from, ind_to) in the minimum spanning tree.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ind_from: int</span>
<span class="sd">            starting node in the directed graph</span>
<span class="sd">        ind_to: int</span>
<span class="sd">            ending node in the directed graph</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        ind: int</span>
<span class="sd">            corresponding ind in the original graph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cgraph_from</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="n">ind_from</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_to</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">ind_to</span><span class="p">:</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">ind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cgraph_to</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">f</span> <span class="o">==</span> <span class="n">ind_from</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cgraph_from</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">ind_to</span><span class="p">:</span>
                        <span class="n">ind</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">ind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Error: can&#39;&#39;t find matching vertex pair.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ind</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline._process_RGB_for_display"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline._process_RGB_for_display">[docs]</a>    <span class="k">def</span> <span class="nf">_process_RGB_for_display</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process RGB data for correctly displaying it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u: ndarray</span>
<span class="sd">            RGB data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data_to_display: ndarray</span>
<span class="sd">            RGB data displayable with correct contrast and colors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_to_display</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">u</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">200</span><span class="p">)</span>
            <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">200</span><span class="p">)],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">99.9</span><span class="p">))</span>
            <span class="n">data_to_display</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rescale_intensity</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">in_range</span><span class="o">=</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">),</span> <span class="n">out_range</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data_to_display</span></div>

<div class="viewcode-block" id="clearscopeRunningPipeline.plot_stitching_info"><a class="viewcode-back" href="../../paprica.runner.html#paprica.runner.clearscopeRunningPipeline.plot_stitching_info">[docs]</a>    <span class="k">def</span> <span class="nf">plot_stitching_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot pair-wise registration error for each axis [H, V, D].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_tree_H</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: minimum spanning tree not computed yet, please use optimize_sparse_graph()&#39;</span>
                            <span class="s1">&#39;before trying to plot stitching info.&#39;</span><span class="p">)</span>

        <span class="n">rel_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">]):</span>
            <span class="n">ind_from</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ctree_from_&#39;</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">ind_to</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ctree_to_&#39;</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;graph_relia_&#39;</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">ind_to</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">ind_from</span><span class="p">,</span> <span class="n">ind_to</span><span class="p">):</span>
                <span class="n">rel</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">]</span>
                <span class="n">rel_map</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">rel_map</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">],</span> <span class="n">rel</span><span class="p">))</span>
            <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">ind_from</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">ind_from</span><span class="p">,</span> <span class="n">ind_to</span><span class="p">):</span>
                <span class="n">rel</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">]</span>
                <span class="n">rel_map</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="n">rel_map</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">],</span> <span class="n">rel</span><span class="p">))</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">]):</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">rel_map</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;turbo&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Registration </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
            <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s1">&#39;5%&#39;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Estimated error [a.u.]&#39;</span><span class="p">)</span>


        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">rel_map</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;turbo&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;Total stimated error [a.u.]&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph_relia_H</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Error: graph not build yet, please use build_sparse_graph()&#39;</span>
                            <span class="s1">&#39;before trying to plot the graph.&#39;</span><span class="p">)</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="s1">&#39;V&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">]):</span>


            <span class="n">ind_from</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;cgraph_from&#39;</span><span class="p">)</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">ind_from</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
            <span class="n">V1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="mf">0.25</span>

            <span class="n">ind_to</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;cgraph_to&#39;</span><span class="p">)</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">ind_to</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
            <span class="n">V2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="mf">0.25</span>

            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="s1">&#39;ko&#39;</span><span class="p">,</span> <span class="n">markerfacecolor</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="s1">&#39; tree&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>

            <span class="n">ind_from</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ctree_from_&#39;</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">ind_from</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
            <span class="n">V1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="mf">0.25</span>

            <span class="n">ind_to</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ctree_to_&#39;</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">ind_to</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nrow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
            <span class="n">V2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="o">+</span><span class="mf">0.25</span>

            <span class="n">dX</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="s1">&#39;ko-&#39;</span><span class="p">,</span> <span class="n">markerfacecolor</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">transform_point</span><span class="p">([</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">transform_point</span><span class="p">([</span><span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
                <span class="n">dy</span> <span class="o">=</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">dy</span><span class="p">,</span> <span class="n">dx</span><span class="p">))</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_ind</span><span class="p">(</span><span class="n">ind_from</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="n">ind_to</span><span class="p">[</span><span class="n">ii</span><span class="p">])]),</span>
                               <span class="n">xy</span><span class="o">=</span><span class="p">((</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">V1</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">V2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
                               <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                               <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                               <span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
                               <span class="n">rotation</span><span class="o">=</span><span class="n">rot</span><span class="p">,</span>
                               <span class="n">backgroundcolor</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span>
                               <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>

            <span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">registration_map_abs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">annot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;4.0f&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div></div>



<span class="c1"># class colmRunningPipeline():</span>
<span class="c1">#</span>
<span class="c1">#     def __init__(self, path, n_channels, output_path=None):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Constructor for the clearscopeRunningPipeline.</span>
<span class="c1">#</span>
<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         path: str</span>
<span class="c1">#             Path of the acquisition. It has to be the acquisition folder (root of /0001/ folder).</span>
<span class="c1">#         n_channels: int</span>
<span class="c1">#             Number of channels that will be acquired. This will be parsed/guessed in the future.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#         # runningPipeline attributes</span>
<span class="c1">#         self.path = os.path.join(path, &#39;VW0&#39;)</span>
<span class="c1">#         self.folder_settings, self.name_acq = os.path.split(path)</span>
<span class="c1">#         if output_path is None:</span>
<span class="c1">#             self.output_path = self.path</span>
<span class="c1">#         else:</span>
<span class="c1">#             self.output_path = output_path</span>
<span class="c1">#         self.frame_size = 2048</span>
<span class="c1">#         self.n_channels = n_channels</span>
<span class="c1">#         self.tile_processed = 0</span>
<span class="c1">#         self.type = &#39;colm&#39;</span>
<span class="c1">#         self.current_tile = 1</span>
<span class="c1">#         self.current_channel = 0</span>
<span class="c1">#</span>
<span class="c1">#         # Parsing acquisition parameters</span>
<span class="c1">#         self.acq_param = None</span>
<span class="c1">#         self.nrow = None</span>
<span class="c1">#         self.ncol = None</span>
<span class="c1">#         self.n_planes = None</span>
<span class="c1">#         self.overlap_v = None</span>
<span class="c1">#         self.overlap_h = None</span>
<span class="c1">#         self._parse_acquisition_settings()</span>
<span class="c1">#         self.n_tiles = self.nrow * self.ncol</span>
<span class="c1">#         self.projs = np.empty((self.nrow, self.ncol), dtype=object)</span>
<span class="c1">#</span>
<span class="c1">#         # Converter attributes</span>
<span class="c1">#         self.converter = None</span>
<span class="c1">#         self.lazy_loading = None</span>
<span class="c1">#         self.compression = False</span>
<span class="c1">#         self.bg = None</span>
<span class="c1">#         self.quantization_factor = None</span>
<span class="c1">#         self.folder_apr = None</span>
<span class="c1">#</span>
<span class="c1">#         # Stitcher attributes</span>
<span class="c1">#         self.stitcher = None</span>
<span class="c1">#         self.n_vertex = None</span>
<span class="c1">#         self.folder_max_projs = None</span>
<span class="c1">#</span>
<span class="c1">#         self.mask = False</span>
<span class="c1">#         self.threshold = None</span>
<span class="c1">#</span>
<span class="c1">#         self.segment = False</span>
<span class="c1">#         self.segmenter = None</span>
<span class="c1">#</span>
<span class="c1">#         self.reg_x = int(self.frame_size * 0.05)</span>
<span class="c1">#         self.reg_y = int(self.frame_size * 0.05)</span>
<span class="c1">#         self.reg_z = 20</span>
<span class="c1">#</span>
<span class="c1">#         self.z_begin = None</span>
<span class="c1">#         self.z_end = None</span>
<span class="c1">#</span>
<span class="c1">#         self.cgraph_from = []</span>
<span class="c1">#         self.cgraph_to = []</span>
<span class="c1">#         self.relia_H = []</span>
<span class="c1">#         self.relia_V = []</span>
<span class="c1">#         self.relia_D = []</span>
<span class="c1">#         self.dH = []</span>
<span class="c1">#         self.dV = []</span>
<span class="c1">#         self.dD = []</span>
<span class="c1">#</span>
<span class="c1">#         # Attributes below are set when the corresponding method are called.</span>
<span class="c1">#         self.registration_map_rel = None</span>
<span class="c1">#         self.registration_map_abs = None</span>
<span class="c1">#         self.ctree_from_H = None</span>
<span class="c1">#         self.ctree_from_V = None</span>
<span class="c1">#         self.ctree_from_D = None</span>
<span class="c1">#         self.ctree_to_H = None</span>
<span class="c1">#         self.ctree_to_V = None</span>
<span class="c1">#         self.ctree_to_D = None</span>
<span class="c1">#         self.min_tree_H = None</span>
<span class="c1">#         self.min_tree_V = None</span>
<span class="c1">#         self.min_tree_D = None</span>
<span class="c1">#         self.graph_relia_H = None</span>
<span class="c1">#         self.graph_relia_V = None</span>
<span class="c1">#         self.graph_relia_D = None</span>
<span class="c1">#         self.database = None</span>
<span class="c1">#</span>
<span class="c1">#     def run(self):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Start the running pipeline. It is basically a loop waiting for each tile to be saved at the specified path.</span>
<span class="c1">#</span>
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         None</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#         while self.tile_processed &lt; self.n_tiles:</span>
<span class="c1">#</span>
<span class="c1">#             is_available, tile = self._is_new_tile_available()</span>
<span class="c1">#</span>
<span class="c1">#             if is_available:</span>
<span class="c1">#</span>
<span class="c1">#                 print(&#39;\nNew tile available: {}\nrow: {}\ncol {}\nchannel {}&#39;.format(tile.path,</span>
<span class="c1">#                                                                                      tile.row,</span>
<span class="c1">#                                                                                      tile.col,</span>
<span class="c1">#                                                                                      tile.channel))</span>
<span class="c1">#</span>
<span class="c1">#                 # We check if the APR file is already available (e.g. something crashed and we restart the pipeline)</span>
<span class="c1">#                 apr, parts = self._check_for_apr_file(tile)</span>
<span class="c1">#                 if apr is None:</span>
<span class="c1">#                     tile.load_tile()</span>
<span class="c1">#</span>
<span class="c1">#                     # Convert tile</span>
<span class="c1">#                     if self.converter is not None:</span>
<span class="c1">#                         self._convert_to_apr(tile)</span>
<span class="c1">#                         self._check_conversion(tile)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     tile.apr = apr</span>
<span class="c1">#                     tile.parts = parts</span>
<span class="c1">#</span>
<span class="c1">#                 if self.stitcher is True:</span>
<span class="c1">#                     self._pre_stitch(tile)</span>
<span class="c1">#</span>
<span class="c1">#                 self._update_next_tile()</span>
<span class="c1">#</span>
<span class="c1">#                 self.tile_processed += 1</span>
<span class="c1">#             else:</span>
<span class="c1">#                 sleep(1)</span>
<span class="c1">#</span>
<span class="c1">#         if self.stitcher:</span>
<span class="c1">#             self._build_sparse_graphs()</span>
<span class="c1">#             self._optimize_sparse_graphs()</span>
<span class="c1">#             _, _ = self._produce_registration_map()</span>
<span class="c1">#             self._build_database()</span>
<span class="c1">#             self._print_info()</span>
<span class="c1">#</span>
<span class="c1">#     def activate_conversion(self,</span>
<span class="c1">#                             Ip_th=108,</span>
<span class="c1">#                             rel_error=0.2,</span>
<span class="c1">#                             gradient_smoothing=2,</span>
<span class="c1">#                             dx=1,</span>
<span class="c1">#                             dy=1,</span>
<span class="c1">#                             dz=1,</span>
<span class="c1">#                             lazy_loading=True):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Activate conversion for the running pipeline.</span>
<span class="c1">#</span>
<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         Ip_th: int</span>
<span class="c1">#             Intensity threshold</span>
<span class="c1">#         rel_error: float in [0, 1[</span>
<span class="c1">#             relative error bound</span>
<span class="c1">#         gradient_smoothing: (float)</span>
<span class="c1">#             B-Spline smoothing parameter (typically between 0 (no smoothing) and 10 (LOTS of smoothing)</span>
<span class="c1">#         dx: float</span>
<span class="c1">#             PSF size in x, used to compute the gradient</span>
<span class="c1">#         dy: float</span>
<span class="c1">#             PSF size in y, used to compute the gradient</span>
<span class="c1">#         dz: float</span>
<span class="c1">#             PSF size in z, used to compute the gradient</span>
<span class="c1">#         lazy_loading: bool</span>
<span class="c1">#             if lazy_loading is true then the converter save mean tree particle which are necessary for lazy loading of</span>
<span class="c1">#             the APR. It will require about 1/7 more storage.</span>
<span class="c1">#</span>
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         None</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#         # Store parameters</span>
<span class="c1">#         self.lazy_loading = lazy_loading</span>
<span class="c1">#</span>
<span class="c1">#         # Safely create folder to save apr data</span>
<span class="c1">#         for i in range(self.n_channels):</span>
<span class="c1">#             self.folder_apr = os.path.join(self.output_path, &#39;APR&#39;)</span>
<span class="c1">#             Path(os.path.join(self.folder_apr, &#39;ch{}&#39;.format(i))).mkdir(parents=True, exist_ok=True)</span>
<span class="c1">#</span>
<span class="c1">#         # Set parameters</span>
<span class="c1">#         par = pyapr.APRParameters()</span>
<span class="c1">#         par.Ip_th = Ip_th</span>
<span class="c1">#         par.rel_error = rel_error</span>
<span class="c1">#         par.dx = dx</span>
<span class="c1">#         par.dy = dy</span>
<span class="c1">#         par.dz = dz</span>
<span class="c1">#         par.gradient_smoothing = gradient_smoothing</span>
<span class="c1">#         par.auto_parameters = True</span>
<span class="c1">#</span>
<span class="c1">#         # Create converter object</span>
<span class="c1">#         self.converter = pyapr.converter.FloatConverter()</span>
<span class="c1">#         self.converter.set_parameters(par)</span>
<span class="c1">#         self.converter.verbose = True</span>
<span class="c1">#</span>
<span class="c1">#     def set_compression(self, quantization_factor=1, bg=108):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Activate B3D compression for saving tiles.</span>
<span class="c1">#</span>
<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         quantization_factor: int</span>
<span class="c1">#             quantization factor: the higher, the more compressed (refer to B3D paper for more detail).</span>
<span class="c1">#         bg: int</span>
<span class="c1">#             background value: any value below this threshold will be set to the background value. This helps</span>
<span class="c1">#             save up space by having the same value for the background (refer to B3D paper for more details).</span>
<span class="c1">#</span>
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         None</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#         self.compression = True</span>
<span class="c1">#         self.bg = bg</span>
<span class="c1">#         self.quantization_factor = quantization_factor</span>
<span class="c1">#</span>
<span class="c1">#     def deactivate_compression(self):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Deactivate B3D compression when saving particles.</span>
<span class="c1">#</span>
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         None</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#         self.compression = False</span>
<span class="c1">#         self.bg = None</span>
<span class="c1">#         self.quantization_factor = None</span>
<span class="c1">#</span>
<span class="c1">#     def activate_stitching(self, channel):</span>
<span class="c1">#</span>
<span class="c1">#         self.stitcher = True</span>
<span class="c1">#         self.stitched_channel = channel</span>
<span class="c1">#</span>
<span class="c1">#         # Safely create folder to save max projs</span>
<span class="c1">#         self.folder_max_projs = os.path.join(self.output_path, &#39;max_projs&#39;)</span>
<span class="c1">#         Path(os.path.join(self.folder_max_projs, &#39;ch{}&#39;.format(channel))).mkdir(parents=True, exist_ok=True)</span>
<span class="c1">#</span>
<span class="c1">#     def set_regularization(self, reg_x, reg_y, reg_z):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Set the regularization for the stitching to prevent aberrant displacements.</span>
<span class="c1">#</span>
<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         reg_x: int</span>
<span class="c1">#             if the horizontal displacement computed in the pairwise registration for any tile is greater than</span>
<span class="c1">#             reg_x (in pixel unit) then the expected displacement (from motor position) is taken.</span>
<span class="c1">#         reg_y: int</span>
<span class="c1">#             if the horizontal displacement computed in the pairwise registration for any tile is greater than</span>
<span class="c1">#             reg_z (in pixel unit) then the expected displacement (from motor position) is taken.</span>
<span class="c1">#         reg_z: int</span>
<span class="c1">#             if the horizontal displacement computed in the pairwise registration for any tile is greater than</span>
<span class="c1">#             reg_z (in pixel unit) then the expected displacement (from motor position) is taken.</span>
<span class="c1">#</span>
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         None</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#         self.reg_x = reg_x</span>
<span class="c1">#         self.reg_y = reg_y</span>
<span class="c1">#         self.reg_z = reg_z</span>
<span class="c1">#</span>
<span class="c1">#     def _check_for_apr_file(self, tile):</span>
<span class="c1">#</span>
<span class="c1">#         apr_path = os.path.join(self.folder_apr, &#39;ch{}&#39;.format(tile.channel),</span>
<span class="c1">#                                 &#39;{}_{}.apr&#39;.format(tile.row, tile.col))</span>
<span class="c1">#         if os.path.exists(apr_path):</span>
<span class="c1">#             apr, parts = pyapr.io.read(apr_path)</span>
<span class="c1">#             print(&#39;Tile {}_{}.apr already exists!&#39;.format(tile.row, tile.col))</span>
<span class="c1">#             return apr, parts</span>
<span class="c1">#         else:</span>
<span class="c1">#             return None, None</span>
<span class="c1">#</span>
<span class="c1">#     def _parse_acquisition_settings(self):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Function that parses the setting txt file created by cleascope software at the begining of the acquisition</span>
<span class="c1">#         and automatically extract the required parameters for the running pipeline to work.</span>
<span class="c1">#</span>
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         None</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#         print(&#39;Waiting for Scanned Cells.txt file in {}&#39;.</span>
<span class="c1">#               format(os.path.join(self.folder_settings, &#39;Scanned Cells.txt&#39;.format(self.name_acq))))</span>
<span class="c1">#</span>
<span class="c1">#         files = glob(os.path.join(path, &#39;Scanned Cells.txt&#39;), delimiter=&#39;,&#39;)</span>
<span class="c1">#         self.ncol = u.shape[1]</span>
<span class="c1">#         self.nrow = u.shape[0]</span>
<span class="c1">#         while files == []:</span>
<span class="c1">#             sleep(1)</span>
<span class="c1">#             files = glob(os.path.join(self.folder_settings, &#39;{}_AcquireSettings.txt&#39;.format(self.name_acq)))</span>
<span class="c1">#</span>
<span class="c1">#         path = files[0]</span>
<span class="c1">#         print(&#39;File found: {}&#39;.format(path))</span>
<span class="c1">#</span>
<span class="c1">#         with open(path) as f:</span>
<span class="c1">#             lines = f.readlines()</span>
<span class="c1">#</span>
<span class="c1">#         self.acq_param = {}</span>
<span class="c1">#         for l in lines:</span>
<span class="c1">#             pattern_matched = re.match(&#39;^(\w*) = (.*)$&#39;, l)</span>
<span class="c1">#             if pattern_matched is not None:</span>
<span class="c1">#                 if pattern_matched.group(2).isnumeric():</span>
<span class="c1">#                     self.acq_param[pattern_matched.group(1)] = float(pattern_matched.group(2))</span>
<span class="c1">#                 elif pattern_matched.group(2) == &#39;True&#39;:</span>
<span class="c1">#                     self.acq_param[pattern_matched.group(1)] = True</span>
<span class="c1">#                 elif pattern_matched.group(2) == &#39;False&#39;:</span>
<span class="c1">#                     self.acq_param[pattern_matched.group(1)] = False</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     self.acq_param[pattern_matched.group(1)] = pattern_matched.group(2)</span>
<span class="c1">#</span>
<span class="c1">#         self.nrow = int(self.acq_param[&#39;ScanGridY&#39;])</span>
<span class="c1">#         self.ncol = int(self.acq_param[&#39;ScanGridY&#39;])</span>
<span class="c1">#         self.n_planes = int(self.acq_param[&#39;StackDepths&#39;])</span>
<span class="c1">#</span>
<span class="c1">#         self.expected_overlap_v = self.acq_param[&#39;VSThrowAwayYBottom&#39;]</span>
<span class="c1">#         self.expected_overlap_h = self.acq_param[&#39;VSThrowAwayXRight&#39;]</span>
<span class="c1">#</span>
<span class="c1">#         self.overlap_h = int(self.expected_overlap_h * 1.2)</span>
<span class="c1">#         if self.expected_overlap_h &gt; self.frame_size:</span>
<span class="c1">#             self.expected_overlap_h = self.frame_size</span>
<span class="c1">#         self.overlap_v = int(self.expected_overlap_v * 1.2)</span>
<span class="c1">#         if self.expected_overlap_v &gt; self.frame_size:</span>
<span class="c1">#             self.expected_overlap_v = self.frame_size</span>
<span class="c1">#</span>
<span class="c1">#         print(&#39;\nAcquisition parameters:&#39;</span>
<span class="c1">#               &#39;\n- number of row: {}&#39;</span>
<span class="c1">#               &#39;\n- number of col: {}&#39;</span>
<span class="c1">#               &#39;\n- number of planes: {}&#39;</span>
<span class="c1">#               &#39;\n- number of channels: {}&#39;</span>
<span class="c1">#               &#39;\n- horizontal overlap: {:0.2f}%&#39;</span>
<span class="c1">#               &#39;\n- vertical overlap: {:0.2f}%&#39;</span>
<span class="c1">#               .format(self.nrow, self.ncol, self.n_planes, self.n_channels,</span>
<span class="c1">#                       self.expected_overlap_h / self.frame_size * 100,</span>
<span class="c1">#                       self.expected_overlap_v / self.frame_size * 100))</span>
<span class="c1">#</span>
<span class="c1">#     def _is_new_tile_available(self):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Checks if a new tile is available for processing.</span>
<span class="c1">#</span>
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         is_available: bool</span>
<span class="c1">#             True if a new tile is available, False otherwise</span>
<span class="c1">#         tile: tileLoader</span>
<span class="c1">#             tile object is available, None otherwise</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#         expected_tile = os.path.join(self.path, &#39;000000_{:06d}___{}c/&#39;.format(self.current_tile, self.current_channel))</span>
<span class="c1">#         path = glob(expected_tile)</span>
<span class="c1">#</span>
<span class="c1">#         if path == []:</span>
<span class="c1">#             return False, None</span>
<span class="c1">#         elif len(path) == 1:</span>
<span class="c1">#             # Store current tile coordinate</span>
<span class="c1">#             files = glob(os.path.join(expected_tile, &#39;*.tif&#39;))</span>
<span class="c1">#             if len(files) &lt; self.n_planes:</span>
<span class="c1">#                 return False, None</span>
<span class="c1">#             else:</span>
<span class="c1">#                 tile = self._get_tile(expected_tile)</span>
<span class="c1">#</span>
<span class="c1">#             return True, tile</span>
<span class="c1">#         else:</span>
<span class="c1">#             raise TypeError(&#39;Error: multiple tiles were found.&#39;)</span>
<span class="c1">#</span>
<span class="c1">#     def _get_row_col(self, path):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Get ClearScope tile row and col position given the tile number.</span>
<span class="c1">#</span>
<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         n: int</span>
<span class="c1">#             ClearScope tile number</span>
<span class="c1">#</span>
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         row: int</span>
<span class="c1">#             row number</span>
<span class="c1">#         col: int</span>
<span class="c1">#             col number</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#         pattern_search = re.findall(&#39;\d{6}_(\d{6})___\dc&#39;, path)</span>
<span class="c1">#</span>
<span class="c1">#         if pattern_search != []:</span>
<span class="c1">#             n = int(pattern_search[0])</span>
<span class="c1">#</span>
<span class="c1">#         col = np.absolute(np.mod(n - self.ncol - 1, 2 * self.ncol) - self.ncol + 0.5) + 0.5</span>
<span class="c1">#         row = np.ceil(n / self.ncol)</span>
<span class="c1">#</span>
<span class="c1">#         col = int(col - 1)</span>
<span class="c1">#         row = int(row - 1)</span>
<span class="c1">#</span>
<span class="c1">#         return row, col</span>
<span class="c1">#</span>
<span class="c1">#     def _get_channel(self, path):</span>
<span class="c1">#</span>
<span class="c1">#         pattern_search = re.findall(&#39;\d{6}_\d{6}___(\d)c&#39;, path)</span>
<span class="c1">#</span>
<span class="c1">#         if pattern_search != []:</span>
<span class="c1">#             return int(pattern_search[0])</span>
<span class="c1">#</span>
<span class="c1">#     def _update_next_tile(self):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Update next tile coordinates given the expected pattern.</span>
<span class="c1">#</span>
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         None</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         if self.current_channel == self.n_channels - 1:</span>
<span class="c1">#             self.current_tile += 1</span>
<span class="c1">#             self.current_channel = 0</span>
<span class="c1">#         else:</span>
<span class="c1">#             self.current_channel += 1</span>
<span class="c1">#</span>
<span class="c1">#     def _get_tile(self, path):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Returns the tile at the given path.</span>
<span class="c1">#</span>
<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         path: string</span>
<span class="c1">#             tile path</span>
<span class="c1">#</span>
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         tile: tileLoader</span>
<span class="c1">#             tile object</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#         row, col = self._get_row_col(path)</span>
<span class="c1">#         channel = self._get_channel(path)</span>
<span class="c1">#</span>
<span class="c1">#         # If row is even then neighbors are west and north</span>
<span class="c1">#         if row % 2 == 0:</span>
<span class="c1">#             # If first row then it is only west</span>
<span class="c1">#             if row == 0:</span>
<span class="c1">#                 if col &gt; 0:</span>
<span class="c1">#                     neighbors = [[row, col - 1]]</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     neighbors = None</span>
<span class="c1">#             # Else it is also north</span>
<span class="c1">#             else:</span>
<span class="c1">#                 if col &gt; 0:</span>
<span class="c1">#                     neighbors = [[row, col - 1], [row - 1, col]]</span>
<span class="c1">#                 # Except for first column it is only north</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     neighbors = [[row - 1, col]]</span>
<span class="c1">#         # If row is odd then neighbors are north and east</span>
<span class="c1">#         else:</span>
<span class="c1">#             if col &lt; self.ncol - 1:</span>
<span class="c1">#                 neighbors = [[row - 1, col], [row, col + 1]]</span>
<span class="c1">#             # If last column then there is no east neighbor</span>
<span class="c1">#             else:</span>
<span class="c1">#                 neighbors = [[row - 1, col]]</span>
<span class="c1">#</span>
<span class="c1">#         return paprica.loader.tileLoader(path=path,</span>
<span class="c1">#                                         row=row,</span>
<span class="c1">#                                         col=col,</span>
<span class="c1">#                                         ftype=self.type,</span>
<span class="c1">#                                         neighbors=neighbors,</span>
<span class="c1">#                                         neighbors_tot=None,</span>
<span class="c1">#                                         neighbors_path=None,</span>
<span class="c1">#                                         frame_size=2048,</span>
<span class="c1">#                                         folder_root=self.path,</span>
<span class="c1">#                                         channel=channel)</span>
<span class="c1">#</span>
<span class="c1">#     def _pre_stitch(self, tile):</span>
<span class="c1">#</span>
<span class="c1">#         if tile.channel == self.stitched_channel:</span>
<span class="c1">#             # Max project current tile on the overlaping area.</span>
<span class="c1">#             self._project_tile(tile)</span>
<span class="c1">#             # Compute pair-wise registration with existing neighbors</span>
<span class="c1">#             if tile.neighbors is not None:</span>
<span class="c1">#                 self._register_tile(tile)</span>
<span class="c1">#</span>
<span class="c1">#     def _register_tile(self, tile):</span>
<span class="c1">#         proj1 = self.projs[tile.row, tile.col]</span>
<span class="c1">#</span>
<span class="c1">#         for coords in tile.neighbors:</span>
<span class="c1">#             proj2 = self.projs[coords[0], coords[1]]</span>
<span class="c1">#</span>
<span class="c1">#             if tile.row == coords[0]:</span>
<span class="c1">#                 if tile.col &lt; coords[1]:</span>
<span class="c1">#                     # EAST</span>
<span class="c1">#                     if self.mask:</span>
<span class="c1">#                         reg, rel = _get_masked_proj_shifts(proj1[&#39;east&#39;], proj2[&#39;west&#39;], threshold=self.threshold)</span>
<span class="c1">#                     else:</span>
<span class="c1">#                         reg, rel = _get_proj_shifts(proj1[&#39;east&#39;], proj2[&#39;west&#39;])</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     # WEST</span>
<span class="c1">#                     if self.mask:</span>
<span class="c1">#                         reg, rel = _get_masked_proj_shifts(proj1[&#39;west&#39;], proj2[&#39;east&#39;], threshold=self.threshold)</span>
<span class="c1">#                     else:</span>
<span class="c1">#                         reg, rel = _get_proj_shifts(proj1[&#39;west&#39;], proj2[&#39;east&#39;])</span>
<span class="c1">#</span>
<span class="c1">#             elif tile.col == coords[1]:</span>
<span class="c1">#                 if tile.row &lt; coords[0]:</span>
<span class="c1">#                     # SOUTH</span>
<span class="c1">#                     if self.mask:</span>
<span class="c1">#                         reg, rel = _get_masked_proj_shifts(proj1[&#39;south&#39;], proj2[&#39;north&#39;], threshold=self.threshold)</span>
<span class="c1">#                     else:</span>
<span class="c1">#                         reg, rel = _get_proj_shifts(proj1[&#39;south&#39;], proj2[&#39;north&#39;])</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     # NORTH</span>
<span class="c1">#                     if self.mask:</span>
<span class="c1">#                         reg, rel = _get_masked_proj_shifts(proj1[&#39;north&#39;], proj2[&#39;south&#39;], threshold=self.threshold)</span>
<span class="c1">#                     else:</span>
<span class="c1">#                         reg, rel = _get_proj_shifts(proj1[&#39;north&#39;], proj2[&#39;south&#39;])</span>
<span class="c1">#</span>
<span class="c1">#             else:</span>
<span class="c1">#                 raise TypeError(&#39;Error: couldn&#39;&#39;t determine registration to perform.&#39;)</span>
<span class="c1">#</span>
<span class="c1">#             self.cgraph_from.append(np.ravel_multi_index([tile.row, tile.col],</span>
<span class="c1">#                                                          dims=(self.nrow, self.ncol)))</span>
<span class="c1">#             self.cgraph_to.append(np.ravel_multi_index([coords[0], coords[1]],</span>
<span class="c1">#                                                        dims=(self.nrow, self.ncol)))</span>
<span class="c1">#</span>
<span class="c1">#             # Regularize in case of aberrant displacements</span>
<span class="c1">#             reg, rel = self._regularize(reg, rel)</span>
<span class="c1">#</span>
<span class="c1">#             # H=x, V=y, D=z</span>
<span class="c1">#             self.dH.append(reg[2])</span>
<span class="c1">#             self.dV.append(reg[1])</span>
<span class="c1">#             self.dD.append(reg[0])</span>
<span class="c1">#             self.relia_H.append(rel[2])</span>
<span class="c1">#             self.relia_V.append(rel[1])</span>
<span class="c1">#             self.relia_D.append(rel[0])</span>
<span class="c1">#</span>
<span class="c1">#     def _project_tile(self, tile):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Perform maximum intensity projection of the tile in the overlap area (+ predefined margin). For each tile</span>
<span class="c1">#         a dictionnary ´tile´ is created and the ´[&#39;zy&#39;, &#39;zx&#39;, &#39;yx&#39;]´ projections are save as a list in the dictionnary</span>
<span class="c1">#         where the key corresponds to the edge location ´[&#39;north&#39;, &#39;south&#39;, &#39;east&#39;, &#39;west&#39;]´.</span>
<span class="c1">#</span>
<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         tile: tileLoader</span>
<span class="c1">#             tile object</span>
<span class="c1">#</span>
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         None</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#         proj = {}</span>
<span class="c1">#         if tile.col + 1 &lt; self.ncol:</span>
<span class="c1">#             # check if projs allready exist:</span>
<span class="c1">#             compute = False</span>
<span class="c1">#             for i, d in enumerate([&#39;zy&#39;, &#39;zx&#39;, &#39;yx&#39;]):</span>
<span class="c1">#                 path_to_check = os.path.join(self.folder_max_projs,</span>
<span class="c1">#                                              &#39;ch{}&#39;.format(tile.channel),</span>
<span class="c1">#                                              &#39;{}_{}_east_{}.npy&#39;.format(tile.row, tile.col, d))</span>
<span class="c1">#                 if not os.path.exists(path_to_check):</span>
<span class="c1">#                     compute = True</span>
<span class="c1">#</span>
<span class="c1">#             if compute:</span>
<span class="c1">#                 if not tile.is_loaded:</span>
<span class="c1">#                     tile.load_tile()</span>
<span class="c1">#</span>
<span class="c1">#                 # EAST 1</span>
<span class="c1">#                 patch = pyapr.ReconPatch()</span>
<span class="c1">#                 patch.y_begin = self.frame_size - self.overlap_h</span>
<span class="c1">#                 if self.z_begin is None:</span>
<span class="c1">#                     proj[&#39;east&#39;] = _get_max_proj_apr(tile.apr, tile.parts, patch, plot=False)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     patch_yx = pyapr.ReconPatch()</span>
<span class="c1">#                     patch_yx.y_begin = self.frame_size - self.overlap_h</span>
<span class="c1">#                     patch_yx.z_begin = self.z_begin</span>
<span class="c1">#                     patch_yx.z_end = self.z_end</span>
<span class="c1">#                     proj[&#39;east&#39;] = _get_max_proj_apr(tile.apr, tile.parts, patch=patch, patch_yx=patch_yx,</span>
<span class="c1">#                                                      plot=False)</span>
<span class="c1">#                 for i, d in enumerate([&#39;zy&#39;, &#39;zx&#39;, &#39;yx&#39;]):</span>
<span class="c1">#                     np.save(os.path.join(self.folder_max_projs,</span>
<span class="c1">#                                          &#39;ch{}&#39;.format(tile.channel),</span>
<span class="c1">#                                          &#39;{}_{}_east_{}.npy&#39;.format(tile.row, tile.col, d)), proj[&#39;east&#39;][i])</span>
<span class="c1">#             else:</span>
<span class="c1">#                 proj[&#39;east&#39;] = []</span>
<span class="c1">#                 for i, d in enumerate([&#39;zy&#39;, &#39;zx&#39;, &#39;yx&#39;]):</span>
<span class="c1">#                     proj[&#39;east&#39;].append(np.load(os.path.join(self.folder_max_projs,</span>
<span class="c1">#                                                              &#39;ch{}&#39;.format(tile.channel),</span>
<span class="c1">#                                                              &#39;{}_{}_east_{}.npy&#39;.format(tile.row, tile.col, d))))</span>
<span class="c1">#</span>
<span class="c1">#         if tile.col - 1 &gt;= 0:</span>
<span class="c1">#             # check if projs allready exist:</span>
<span class="c1">#             compute = False</span>
<span class="c1">#             for i, d in enumerate([&#39;zy&#39;, &#39;zx&#39;, &#39;yx&#39;]):</span>
<span class="c1">#                 path_to_check = os.path.join(self.folder_max_projs,</span>
<span class="c1">#                                              &#39;ch{}&#39;.format(tile.channel),</span>
<span class="c1">#                                              &#39;{}_{}_west_{}.npy&#39;.format(tile.row, tile.col, d))</span>
<span class="c1">#                 if not os.path.exists(path_to_check):</span>
<span class="c1">#                     compute = True</span>
<span class="c1">#</span>
<span class="c1">#             if compute:</span>
<span class="c1">#                 if not tile.is_loaded:</span>
<span class="c1">#                     tile.load_tile()</span>
<span class="c1">#</span>
<span class="c1">#                 # EAST 2</span>
<span class="c1">#                 patch = pyapr.ReconPatch()</span>
<span class="c1">#                 patch.y_end = self.overlap_h</span>
<span class="c1">#                 if self.z_begin is None:</span>
<span class="c1">#                     proj[&#39;west&#39;] = _get_max_proj_apr(tile.apr, tile.parts, patch, plot=False)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     patch_yx = pyapr.ReconPatch()</span>
<span class="c1">#                     patch_yx.y_end = self.overlap_h</span>
<span class="c1">#                     patch_yx.z_begin = self.z_begin</span>
<span class="c1">#                     patch_yx.z_end = self.z_end</span>
<span class="c1">#                     proj[&#39;west&#39;] = _get_max_proj_apr(tile.apr, tile.parts, patch=patch, patch_yx=patch_yx,</span>
<span class="c1">#                                                      plot=False)</span>
<span class="c1">#                 for i, d in enumerate([&#39;zy&#39;, &#39;zx&#39;, &#39;yx&#39;]):</span>
<span class="c1">#                     np.save(os.path.join(self.folder_max_projs,</span>
<span class="c1">#                                          &#39;ch{}&#39;.format(tile.channel),</span>
<span class="c1">#                                          &#39;{}_{}_west_{}.npy&#39;.format(tile.row, tile.col, d)), proj[&#39;west&#39;][i])</span>
<span class="c1">#             else:</span>
<span class="c1">#                 proj[&#39;west&#39;] = []</span>
<span class="c1">#                 for i, d in enumerate([&#39;zy&#39;, &#39;zx&#39;, &#39;yx&#39;]):</span>
<span class="c1">#                     proj[&#39;west&#39;].append(np.load(os.path.join(self.folder_max_projs,</span>
<span class="c1">#                                                              &#39;ch{}&#39;.format(tile.channel),</span>
<span class="c1">#                                                              &#39;{}_{}_west_{}.npy&#39;.format(tile.row, tile.col, d))))</span>
<span class="c1">#         if tile.row + 1 &lt; self.nrow:</span>
<span class="c1">#             # check if projs allready exist:</span>
<span class="c1">#             compute = False</span>
<span class="c1">#             for i, d in enumerate([&#39;zy&#39;, &#39;zx&#39;, &#39;yx&#39;]):</span>
<span class="c1">#                 path_to_check = os.path.join(self.folder_max_projs,</span>
<span class="c1">#                                              &#39;ch{}&#39;.format(tile.channel),</span>
<span class="c1">#                                              &#39;{}_{}_south_{}.npy&#39;.format(tile.row, tile.col, d))</span>
<span class="c1">#                 if not os.path.exists(path_to_check):</span>
<span class="c1">#                     compute = True</span>
<span class="c1">#</span>
<span class="c1">#             if compute:</span>
<span class="c1">#                 if not tile.is_loaded:</span>
<span class="c1">#                     tile.load_tile()</span>
<span class="c1">#</span>
<span class="c1">#                 # SOUTH 1</span>
<span class="c1">#                 patch = pyapr.ReconPatch()</span>
<span class="c1">#                 patch.x_begin = self.frame_size - self.overlap_v</span>
<span class="c1">#                 if self.z_begin is None:</span>
<span class="c1">#                     proj[&#39;south&#39;] = _get_max_proj_apr(tile.apr, tile.parts, patch, plot=False)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     patch_yx = pyapr.ReconPatch()</span>
<span class="c1">#                     patch_yx.x_begin = self.frame_size - self.overlap_v</span>
<span class="c1">#                     patch_yx.z_begin = self.z_begin</span>
<span class="c1">#                     patch_yx.z_end = self.z_end</span>
<span class="c1">#                     proj[&#39;south&#39;] = _get_max_proj_apr(tile.apr, tile.parts, patch=patch, patch_yx=patch_yx,</span>
<span class="c1">#                                                       plot=False)</span>
<span class="c1">#                 for i, d in enumerate([&#39;zy&#39;, &#39;zx&#39;, &#39;yx&#39;]):</span>
<span class="c1">#                     np.save(os.path.join(self.folder_max_projs,</span>
<span class="c1">#                                          &#39;ch{}&#39;.format(tile.channel),</span>
<span class="c1">#                                          &#39;{}_{}_south_{}.npy&#39;.format(tile.row, tile.col, d)), proj[&#39;south&#39;][i])</span>
<span class="c1">#             else:</span>
<span class="c1">#                 proj[&#39;south&#39;] = []</span>
<span class="c1">#                 for i, d in enumerate([&#39;zy&#39;, &#39;zx&#39;, &#39;yx&#39;]):</span>
<span class="c1">#                     proj[&#39;south&#39;].append(np.load(os.path.join(self.folder_max_projs,</span>
<span class="c1">#                                                               &#39;ch{}&#39;.format(tile.channel),</span>
<span class="c1">#                                                               &#39;{}_{}_south_{}.npy&#39;.format(tile.row, tile.col, d))))</span>
<span class="c1">#         if tile.row - 1 &gt;= 0:</span>
<span class="c1">#             # check if projs allready exist:</span>
<span class="c1">#             compute = False</span>
<span class="c1">#             for i, d in enumerate([&#39;zy&#39;, &#39;zx&#39;, &#39;yx&#39;]):</span>
<span class="c1">#                 path_to_check = os.path.join(self.folder_max_projs,</span>
<span class="c1">#                                              &#39;ch{}&#39;.format(tile.channel),</span>
<span class="c1">#                                              &#39;{}_{}_north_{}.npy&#39;.format(tile.row, tile.col, d))</span>
<span class="c1">#                 if not os.path.exists(path_to_check):</span>
<span class="c1">#                     compute = True</span>
<span class="c1">#</span>
<span class="c1">#             if compute:</span>
<span class="c1">#                 if not tile.is_loaded:</span>
<span class="c1">#                     tile.load_tile()</span>
<span class="c1">#</span>
<span class="c1">#                 # SOUTH 2</span>
<span class="c1">#                 patch = pyapr.ReconPatch()</span>
<span class="c1">#                 patch.x_end = self.overlap_v</span>
<span class="c1">#                 if self.z_begin is None:</span>
<span class="c1">#                     proj[&#39;north&#39;] = _get_max_proj_apr(tile.apr, tile.parts, patch, plot=False)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     patch_yx = pyapr.ReconPatch()</span>
<span class="c1">#                     patch_yx.x_end = self.overlap_v</span>
<span class="c1">#                     patch_yx.z_begin = self.z_begin</span>
<span class="c1">#                     patch_yx.z_end = self.z_end</span>
<span class="c1">#                     proj[&#39;north&#39;] = _get_max_proj_apr(tile.apr, tile.parts, patch=patch, patch_yx=patch_yx,</span>
<span class="c1">#                                                       plot=False)</span>
<span class="c1">#                 for i, d in enumerate([&#39;zy&#39;, &#39;zx&#39;, &#39;yx&#39;]):</span>
<span class="c1">#                     np.save(os.path.join(self.folder_max_projs,</span>
<span class="c1">#                                          &#39;ch{}&#39;.format(tile.channel),</span>
<span class="c1">#                                          &#39;{}_{}_north_{}.npy&#39;.format(tile.row, tile.col, d)), proj[&#39;north&#39;][i])</span>
<span class="c1">#             else:</span>
<span class="c1">#                 proj[&#39;north&#39;] = []</span>
<span class="c1">#                 for i, d in enumerate([&#39;zy&#39;, &#39;zx&#39;, &#39;yx&#39;]):</span>
<span class="c1">#                     proj[&#39;north&#39;].append(np.load(os.path.join(self.folder_max_projs,</span>
<span class="c1">#                                                               &#39;ch{}&#39;.format(tile.channel),</span>
<span class="c1">#                                                               &#39;{}_{}_north_{}.npy&#39;.format(tile.row, tile.col, d))))</span>
<span class="c1">#</span>
<span class="c1">#         self.projs[tile.row, tile.col] = proj</span>
<span class="c1">#</span>
<span class="c1">#     def _check_conversion(self, tile):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Checks that conversion is ok, if not it should keep the original data.</span>
<span class="c1">#</span>
<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         tile: tileLoader</span>
<span class="c1">#             tile object to try if conversion worked as expected using facy metrics.</span>
<span class="c1">#</span>
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         None</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#         conversion_ok = False</span>
<span class="c1">#</span>
<span class="c1">#         # TODO: implement a way to check if conversion is ok.</span>
<span class="c1">#</span>
<span class="c1">#         if conversion_ok:</span>
<span class="c1">#             tile._erase_from_disk()</span>
<span class="c1">#</span>
<span class="c1">#     def _convert_to_apr(self, tile):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Convert the given tile to APR.</span>
<span class="c1">#</span>
<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         tile: tileLoader</span>
<span class="c1">#             tile object to be converted to APR.</span>
<span class="c1">#</span>
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         None</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#         apr = pyapr.APR()</span>
<span class="c1">#         parts = pyapr.ShortParticles()</span>
<span class="c1">#         self.converter.get_apr(apr, tile.data)</span>
<span class="c1">#         parts.sample_image(apr, tile.data)</span>
<span class="c1">#</span>
<span class="c1">#         if self.compression:</span>
<span class="c1">#             parts.set_compression_type(1)</span>
<span class="c1">#             parts.set_quantization_factor(self.quantization_factor)</span>
<span class="c1">#             parts.set_background(self.bg)</span>
<span class="c1">#</span>
<span class="c1">#         if self.lazy_loading:</span>
<span class="c1">#             tree_parts = pyapr.tree.fill_tree_mean(apr, parts)</span>
<span class="c1">#         else:</span>
<span class="c1">#             tree_parts = None</span>
<span class="c1">#</span>
<span class="c1">#         # Save converted data</span>
<span class="c1">#         filename = &#39;{}_{}.apr&#39;.format(tile.row, tile.col)</span>
<span class="c1">#         pyapr.io.write(os.path.join(self.folder_apr, &#39;ch{}&#39;.format(tile.channel), filename),</span>
<span class="c1">#                        apr, parts, tree_parts=tree_parts)</span>
<span class="c1">#</span>
<span class="c1">#         tile.apr = apr</span>
<span class="c1">#         tile.parts = parts</span>
<span class="c1">#</span>
<span class="c1">#     def _regularize(self, reg, rel):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Remove too large displacement and replace them with expected one with a large uncertainty.</span>
<span class="c1">#</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         if np.abs(reg[2] - (self.overlap_h - self.expected_overlap_h)) &gt; self.reg_x:</span>
<span class="c1">#             reg[2] = (self.overlap_h - self.expected_overlap_h)</span>
<span class="c1">#             rel[2] = 2</span>
<span class="c1">#         if np.abs(reg[1] - (self.overlap_v - self.expected_overlap_v)) &gt; self.reg_y:</span>
<span class="c1">#             reg[1] = (self.overlap_v - self.expected_overlap_v)</span>
<span class="c1">#             rel[1] = 2</span>
<span class="c1">#         if np.abs(reg[0]) &gt; self.reg_z:</span>
<span class="c1">#             reg[0] = 0</span>
<span class="c1">#             rel[0] = 2</span>
<span class="c1">#</span>
<span class="c1">#         return reg, rel</span>
<span class="c1">#</span>
<span class="c1">#     def _print_info(self):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Display stitching result information.</span>
<span class="c1">#</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         overlap = np.median(np.diff(np.median(self.registration_map_abs[0], axis=0)))</span>
<span class="c1">#         self.effective_overlap_h = (self.frame_size - overlap) / self.frame_size * 100</span>
<span class="c1">#         print(&#39;Effective horizontal overlap: {:0.2f}%&#39;.format(self.effective_overlap_h))</span>
<span class="c1">#         overlap = np.median(np.diff(np.median(self.registration_map_abs[1], axis=1)))</span>
<span class="c1">#         self.effective_overlap_v = (self.frame_size - overlap) / self.frame_size * 100</span>
<span class="c1">#         print(&#39;Effective vertical overlap: {:0.2f}%&#39;.format(self.effective_overlap_v))</span>
<span class="c1">#</span>
<span class="c1">#         if np.abs(</span>
<span class="c1">#                 self.effective_overlap_v * self.frame_size / 100 - self.expected_overlap_v) &gt; 0.2 * self.expected_overlap_v:</span>
<span class="c1">#             warnings.warn(&#39;Expected vertical overlap is very different from the computed one, the registration &#39;</span>
<span class="c1">#                           &#39;might be wrong.&#39;)</span>
<span class="c1">#         if np.abs(</span>
<span class="c1">#                 self.effective_overlap_h * self.frame_size / 100 - self.expected_overlap_h) &gt; 0.2 * self.expected_overlap_h:</span>
<span class="c1">#             warnings.warn(&#39;Expected horizontal overlap is very different from the computed one, the registration &#39;</span>
<span class="c1">#                           &#39;might be wrong.&#39;)</span>
<span class="c1">#</span>
<span class="c1">#     def _build_sparse_graphs(self):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Build the sparse graph from the reliability and (row, col). This method needs to be called after the</span>
<span class="c1">#         pair-wise registration has been performed for all neighbors pair.</span>
<span class="c1">#</span>
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         None</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#         csr_matrix_size = self.ncol * self.nrow</span>
<span class="c1">#         self.graph_relia_H = csr_matrix((self.relia_H, (self.cgraph_from, self.cgraph_to)),</span>
<span class="c1">#                                         shape=(csr_matrix_size, csr_matrix_size))</span>
<span class="c1">#         self.graph_relia_V = csr_matrix((self.relia_V, (self.cgraph_from, self.cgraph_to)),</span>
<span class="c1">#                                         shape=(csr_matrix_size, csr_matrix_size))</span>
<span class="c1">#         self.graph_relia_D = csr_matrix((self.relia_D, (self.cgraph_from, self.cgraph_to)),</span>
<span class="c1">#                                         shape=(csr_matrix_size, csr_matrix_size))</span>
<span class="c1">#</span>
<span class="c1">#     def _optimize_sparse_graphs(self):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Optimize the sparse graph by computing the minimum spanning tree for each direction (H, D, V). This</span>
<span class="c1">#         method needs to be called after the sparse graphs have been built.</span>
<span class="c1">#</span>
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         None</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#         if self.graph_relia_H is None:</span>
<span class="c1">#             raise TypeError(&#39;Error: sparse graph not build yet, please use build_sparse_graph() before trying to&#39;</span>
<span class="c1">#                             &#39;perform the optimization.&#39;)</span>
<span class="c1">#</span>
<span class="c1">#         for g in [&#39;graph_relia_H&#39;, &#39;graph_relia_V&#39;, &#39;graph_relia_D&#39;]:</span>
<span class="c1">#             graph = getattr(self, g)</span>
<span class="c1">#             # Minimum spanning tree</span>
<span class="c1">#             min_tree = minimum_spanning_tree(graph)</span>
<span class="c1">#</span>
<span class="c1">#             # Get the &quot;true&quot; neighbors</span>
<span class="c1">#             min_tree = min_tree.tocoo()</span>
<span class="c1">#             setattr(self, &#39;min_tree_&#39; + g[-1], min_tree)</span>
<span class="c1">#             ctree_from = min_tree.row</span>
<span class="c1">#             setattr(self, &#39;ctree_from_&#39; + g[-1], ctree_from)</span>
<span class="c1">#</span>
<span class="c1">#             ctree_to = min_tree.col</span>
<span class="c1">#             setattr(self, &#39;ctree_to_&#39; + g[-1], ctree_to)</span>
<span class="c1">#</span>
<span class="c1">#     def _produce_registration_map(self):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Produce the registration map where reg_rel_map[d, row, col] (d = H,V,D) is the relative tile</span>
<span class="c1">#         position in pixel from the expected one. This method needs to be called after the optimization has been done.</span>
<span class="c1">#</span>
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         None</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#         if self.min_tree_H is None:</span>
<span class="c1">#             raise TypeError(&#39;Error: minimum spanning tree not computed yet, please use optimize_sparse_graph()&#39;</span>
<span class="c1">#                             &#39;before trying to compute the registration map.&#39;)</span>
<span class="c1">#</span>
<span class="c1">#         # Relative registration</span>
<span class="c1">#         # Initialize relative registration map</span>
<span class="c1">#         reg_rel_map = np.zeros((3, self.nrow, self.ncol))  # H, V, D</span>
<span class="c1">#</span>
<span class="c1">#         for i, min_tree in enumerate([&#39;min_tree_H&#39;, &#39;min_tree_V&#39;, &#39;min_tree_D&#39;]):</span>
<span class="c1">#             # Fill it by following the tree and getting the corresponding registration parameters</span>
<span class="c1">#             node_array = depth_first_order(getattr(self, min_tree), i_start=self.cgraph_from[0],</span>
<span class="c1">#                                            directed=False, return_predecessors=False)</span>
<span class="c1">#</span>
<span class="c1">#             node_visited = [node_array[0]]</span>
<span class="c1">#</span>
<span class="c1">#             tree = getattr(self, min_tree)</span>
<span class="c1">#             row = tree.row</span>
<span class="c1">#             col = tree.col</span>
<span class="c1">#</span>
<span class="c1">#             for node_to in zip(node_array[1:]):</span>
<span class="c1">#                 # The previous node in the MST is a visited node with an edge to the current node</span>
<span class="c1">#                 neighbors = []</span>
<span class="c1">#                 for r, c in zip(row, col):</span>
<span class="c1">#                     if r == node_to:</span>
<span class="c1">#                         neighbors.append(c)</span>
<span class="c1">#                     if c == node_to:</span>
<span class="c1">#                         neighbors.append(r)</span>
<span class="c1">#                 node_from = [x for x in neighbors if x in node_visited]</span>
<span class="c1">#                 node_visited.append(node_to)</span>
<span class="c1">#</span>
<span class="c1">#                 # Get the previous neighbor local reg parameter</span>
<span class="c1">#                 ind1, ind2 = np.unravel_index(node_from, shape=(self.nrow, self.ncol))</span>
<span class="c1">#                 d_neighbor = reg_rel_map[i, ind1, ind2]</span>
<span class="c1">#</span>
<span class="c1">#                 # Get the current 2D tile position</span>
<span class="c1">#                 ind1, ind2 = np.unravel_index(node_to, shape=(self.nrow, self.ncol))</span>
<span class="c1">#                 # Get the associated ind position in the registration graph (as opposed to the reliability min_tree)</span>
<span class="c1">#                 ind_graph = self._get_ind(node_from, node_to)</span>
<span class="c1">#                 # Get the corresponding reg parameter</span>
<span class="c1">#                 d = getattr(self, &#39;d&#39; + min_tree[-1])[ind_graph]</span>
<span class="c1">#                 # Get the corresponding relia and print a warning if it was regularized:</span>
<span class="c1">#                 relia = getattr(self, &#39;relia_&#39; + min_tree[-1])[ind_graph]</span>
<span class="c1">#                 if relia == 2:</span>
<span class="c1">#                     print(&#39;Aberrant pair-wise registration remaining after global optimization between tile ({},{}) &#39;</span>
<span class="c1">#                           &#39;and tile ({},{})&#39;.format(*np.unravel_index(node_from, shape=(self.nrow, self.ncol)),</span>
<span class="c1">#                                                     *np.unravel_index(node_to, shape=(self.nrow, self.ncol))))</span>
<span class="c1">#                 # Update the local reg parameter in the 2D matrix</span>
<span class="c1">#                 if node_to &gt; node_from[0]:</span>
<span class="c1">#                     reg_rel_map[i, ind1, ind2] = d_neighbor + d</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     reg_rel_map[i, ind1, ind2] = d_neighbor - d</span>
<span class="c1">#         self.registration_map_rel = reg_rel_map</span>
<span class="c1">#</span>
<span class="c1">#         reg_abs_map = np.zeros_like(reg_rel_map)</span>
<span class="c1">#         # H</span>
<span class="c1">#         for x in range(reg_abs_map.shape[2]):</span>
<span class="c1">#             reg_abs_map[0, :, x] = reg_rel_map[0, :, x] + x * (self.frame_size - self.overlap_h)</span>
<span class="c1">#         # V</span>
<span class="c1">#         for x in range(reg_abs_map.shape[1]):</span>
<span class="c1">#             reg_abs_map[1, x, :] = reg_rel_map[1, x, :] + x * (self.frame_size - self.overlap_v)</span>
<span class="c1">#         # D</span>
<span class="c1">#         reg_abs_map[2] = reg_rel_map[2]</span>
<span class="c1">#         self.registration_map_abs = reg_abs_map</span>
<span class="c1">#</span>
<span class="c1">#         return reg_rel_map, reg_abs_map</span>
<span class="c1">#</span>
<span class="c1">#     def _build_database(self):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Build the database for storing the registration parameters. This method needs to be called after</span>
<span class="c1">#         the registration map has been produced.</span>
<span class="c1">#</span>
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         None</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#         if self.registration_map_rel is None:</span>
<span class="c1">#             raise TypeError(&#39;Error: database can&#39;&#39;t be build if the registration map has not been computed.&#39;</span>
<span class="c1">#                             &#39; Please use produce_registration_map() method first.&#39;)</span>
<span class="c1">#</span>
<span class="c1">#         database_dict = {}</span>
<span class="c1">#         for i in range(self.n_vertex):</span>
<span class="c1">#             row = self.tiles[i].row</span>
<span class="c1">#             col = self.tiles[i].col</span>
<span class="c1">#             database_dict[i] = {&#39;path&#39;: self.tiles[i].path,</span>
<span class="c1">#                                 &#39;row&#39;: row,</span>
<span class="c1">#                                 &#39;col&#39;: col,</span>
<span class="c1">#                                 &#39;dH&#39;: self.registration_map_rel[0, row, col],</span>
<span class="c1">#                                 &#39;dV&#39;: self.registration_map_rel[1, row, col],</span>
<span class="c1">#                                 &#39;dD&#39;: self.registration_map_rel[2, row, col],</span>
<span class="c1">#                                 &#39;ABS_H&#39;: self.registration_map_abs[0, row, col],</span>
<span class="c1">#                                 &#39;ABS_V&#39;: self.registration_map_abs[1, row, col],</span>
<span class="c1">#                                 &#39;ABS_D&#39;: self.registration_map_abs[2, row, col]}</span>
<span class="c1">#</span>
<span class="c1">#         self.database = pd.DataFrame.from_dict(database_dict, orient=&#39;index&#39;)</span>
<span class="c1">#</span>
<span class="c1">#         # Finally set the origin so that tile on the edge have coordinate 0 (rather than negative):</span>
<span class="c1">#         for i, d in enumerate([&#39;ABS_D&#39;, &#39;ABS_V&#39;, &#39;ABS_H&#39;]):</span>
<span class="c1">#             self.database[d] = self.database[d] - self.database[d].min()</span>
<span class="c1">#</span>
<span class="c1">#     def _get_ind(self, ind_from, ind_to):</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         Returns the ind in the original graph which corresponds to (ind_from, ind_to) in the minimum spanning tree.</span>
<span class="c1">#</span>
<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         ind_from: int</span>
<span class="c1">#             starting node in the directed graph</span>
<span class="c1">#         ind_to: int</span>
<span class="c1">#             ending node in the directed graph</span>
<span class="c1">#</span>
<span class="c1">#         Returns</span>
<span class="c1">#         ----------</span>
<span class="c1">#         ind: int</span>
<span class="c1">#             corresponding ind in the original graph</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         ind = None</span>
<span class="c1">#         for i, f in enumerate(self.cgraph_from):</span>
<span class="c1">#             if f == ind_from:</span>
<span class="c1">#                 if self.cgraph_to[i] == ind_to:</span>
<span class="c1">#                     ind = i</span>
<span class="c1">#         if ind is None:</span>
<span class="c1">#             for i, f in enumerate(self.cgraph_to):</span>
<span class="c1">#                 if f == ind_from:</span>
<span class="c1">#                     if self.cgraph_from[i] == ind_to:</span>
<span class="c1">#                         ind = i</span>
<span class="c1">#         if ind is None:</span>
<span class="c1">#             raise ValueError(&#39;Error: can&#39;&#39;t find matching vertex pair.&#39;)</span>
<span class="c1">#         return ind</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Wyss Center for Bio and Neuro Engineering.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>